[["index.html", "Métodos analíticos, ITAM 2022 Temario Evaluación", " Métodos analíticos, ITAM 2022 Felipe González 2022-01-26 Temario Este curso trata sobre diversas técnicas de análisis de datos, en su mayoría diseñadas para escalar a datos grandes. El enfoque del curso se concentra más en el entendimiento y aplicación de los algoritmos y los métodos, y menos en las herramientas para implementarlos. Análisis de conjuntos frecuentes Algoritmo a-priori Market basket analysis Búsqueda de elementos similares Minhashing para documentos Locality Sensitive Hashing (LSH), joins aproximados Sistemas de recomendación 1 Recomendación por contenido y filtros colaborativos Factorización de matrices y dimensiones latentes Reducción de dimensionalidad: DVS Descomposición en valores singulares Componentes principales Sistemas de recomendación 2 Métodos basados en similitud Mínimos cuadrados alternados Descenso en gradiente estocástico Retroalimentación implícita Recuperación de información Índices invertidos Modelo de espacio vectorial Normalización y similitud Indexado semántico latente Análisis de redes 1 Medidas de centralidad y pagerank Análisis de redes 2 Clustering y comunidades Modelos de lenguaje 1 N-gramas y conteos Aplicaciones Modelos de lenguaje 2 Inmersiones de palabras Modelos básicos de redes neuronales Aplicaciones de modelos de lenguaje Corrección de ortografía, reconocimiento de idiomas Clasificación de textos Métodos generales de clustering Las notas del curso están R, y en algunos casos usamos python o línea de comandos. Puedes usar python también para hacer tareas y ejercicios. Nuestro texto básico es (Leskovec, Rajaraman, and Ullman 2014). Referencias básicas adicionales son (Jurafsky and Martin 2000) (para procesamiento de lenguaje natural), y sparklyr para utlizar la interfaz de R a Spark. Evaluación Tareas semanales (30%) Examen teórico parcial (35%) Trabajo final (35%) Referencias "],["intro.html", "1 Introducción Tipos de soluciones", " 1 Introducción En este curso principalmente consideraremos técnicas para procesar, analizar y entender conjuntos de datos en dimensión alta (es decir, existen muchos atributos relevantes que describen a cada observación). Tareas básicas en este curso son, por ejemplo: Entender si las observaciones forman grupos útiles o interpretables, Construir o seleccionar atributos importantes para describir los datos de maneras más simples o útiles, En general, descubrir otros tipos de estructuras interesantes en datos de dimensión alta. Veremos aplicaciones relacionadas con este problema, como Análisis de market basket (descubrir características o artículos asociados), Sistemas de recomendación (medir similitud entre usuarios o artículos para hacer recomendaciones), Búsqueda de elementos muy similares o duplicados, Análisis de redes y detección de comunidades, Análisis y modelos para lenguaje natural. En general, consideraremos técnicas que son escalables y se aplican a datos masivos, que son los casos donde la dimensionalidad alta realmente puede explotarse efectivamente. Comenzaremos por describir las dificultades del análisis en dimensión alta. Simlitud en dimensión alta Cuando queremos identificar casos similares, o agruparlos por similitud, generalmente estamos pensando alguna tarea que queremos resolver: por ejemplo, recomendar productos o contenido a usuarios similares, detectar imágenes o textos duplicados o reusados, focalizar programas sociales a distintos tipos de hogares o personas, etc. Muchas veces, identificar los atributos correctos y el tipo de similitud produce herramientas útiles para resolver varios problemas en cada área de interés. Por ejemplo, la medida correcta de similitud de usuarios de Netflix tiene varios usos, igual que la identificación de palabras o pasajes de texto que ocurren en contextos similares. Consideramos por ejemplo perfiles de actividad en un sitio (Netflix), productos seleccionados por un comprador en un súper, imágenes o textos. En todos estos casos, las observaciones individuales tienen número muy grande de atributos (qué artículos están o no en una canasta, qué películas vio alguien, número de pixeles, o qué palabras ocurren y en qué orden ocurren). Hay varios problemas que tenemos que manejar en dimensión alta: Distintos atributos pueden ser importantes y otros ser no ser relevantes en ciertos grupos o en general. Por ejemplo: si queremos predecir la siguiente palabra en un texto (o traducirlo), la ausencia o presencia de algunas palabras es importantes, y muchas otras palabras son irrelevantes. Puede ser que muchos atributos no sean de interés para formar grupos útiles o identificar casos similares. Los atributos generalmente tienen relaciones complejas, y no es claro qué medidas de similitud son apropiadas. Medidas de distancia o similitud Consideremos la distancia euclideana en dimensión alta. Si generamos una muestra centrada en el origen, las distancias al origen se ve cómo sigue: library(tidyverse) centro &lt;- rep(0, 50) puntos &lt;- MASS::mvrnorm(n = 5000, mu = centro, Sigma = diag(rep(1, 50))) distancias &lt;- map_dbl(1:nrow(puntos), ~ sqrt(sum((centro - puntos[.x, ])^2))) qplot(distancias, bins = 30) Y vemos que ningún punto está realmente cerca del origen, y las distancias varían alrededor de un valor fijo. Si consideramos todos los posibles pares de puntos, vemos que todos parecen estar más o menos igual de lejos unos de otros: dist_pares &lt;- dist(puntos) |&gt; as.numeric() qplot(dist_pares, bins = 30) En dimensión alta, nuestra intuición muchas veces no funciona muy bien. Por ejemplo, supongamos que en una dimensión tenemos dos grupos claros: library(tidyverse) library(patchwork) library(glue) set.seed(10012) x &lt;- rnorm(100, c( -1,1), c(0.2,0.2)) datos &lt;- tibble(id = 1:100, variable = &quot;x&quot;, x = x) |&gt; mutate(grupo = id %% 2) ggplot(datos, aes(x = x, fill = factor(grupo))) + geom_histogram(bins = 30) Podemos calcular las distancias entre pares: distancias_pares &lt;- datos |&gt; select(-id, -grupo) |&gt; dist() |&gt; as.numeric() ## Warning in dist(select(datos, -id, -grupo)): NAs introduced by coercion g_1 &lt;- qplot(distancias_pares, bins = 30) Ahora agregamos 50 variables adiconales_ datos_aleatorios &lt;- map_df(1:50, function(i){ datos |&gt; select(id, grupo) |&gt; mutate(variable = glue(&quot;x_{i}&quot;), x = rnorm(100, 0, 1)) }) datos_1 &lt;- bind_rows(datos, datos_aleatorios) |&gt; pivot_wider(names_from = variable, values_from = x) Y vemos claramente que hay una estructura de grupos en los datos el la gráfica de la izquierda. Sin embargo, si agregamos variables ruidosas, la estructura no es clara y es difícil de recuperar: distancias_pares_2 &lt;- datos_1 |&gt; select(-id, -grupo) |&gt; dist() |&gt; as.numeric() g_2 &lt;- qplot(distancias_pares_2, bins = 30) g_1 + g_2 Si usamos un método simple de clustering, no recuperamos los grupos originales: grupos_km &lt;- kmeans(datos_1 |&gt; select(contains(&quot;x&quot;)), centers = 2) |&gt; pluck(&quot;cluster&quot;) table(grupos_km, datos_1$grupo) ## ## grupos_km 0 1 ## 1 38 29 ## 2 12 21 Tipos de soluciones Proyección y búsqueda de marginales interesantes En primer lugar, puede ser que aspectos útiles puedan extraerse de algunas marginales particulares \\(P(X_1, X_2)\\). Por ejemplo: Hay muchas variables ruidosas, en el sentido que no presentan estructuras interesantes o no son útiles para la tarea que nos interesa. (estas paso tiende a ser más guiado por teoría). Podemos buscamos regiones \\(P(X_1 = x_1, X_2 = x_2)\\) alrededor de las cuales se acumula alta probabilidad, o de otra manera: podemos buscar modas de marginales con alta densidad. Aplicaciones: análisis de conjuntos frecuentes o canastas, selección de características según varianza. Proyecciones globales Muchas veces podemos reducir dimensionalidad si reexpresamos variables (ya sea linealmente o no), y luego proyectamos (descomposición en valores singulares, PCA, descomposición de matrices) a regiones de alta densidad. Aplicaciones: construcción de índices resumen, sistemas de recomendación, indexado semántico latente en análisis de texto. Descripción de estructura local En algunos casos, los datos pueden ser del tipo donde la estructura local en pequeñas regiones del espacio de entradas es importante, y algunos casos tienden a acumularse en regiones particulares: Duplicados cercanos, búsqueda de vecinos cercanos. Análisis de centralidad en redes, búsqueda de comunidades. Métodos de reducción de dimensionalidad como t-sne y clustering Inmersiones (embeddings) Para algunos tipos de datos, la reducción de dimensionalidad debemos hacerla ad-hoc al problema. Por ejemplo, Redes convolucionales de clasificación de imágenes para obtener representaciones en dimensión baja de imágenes (similitud de imágenes). Construcción de representaciones donde palabras que ocurren en lugares similares son proyectadas a valores similares (inmersiones de palabras, redes neuronales para NLP). "],["frecuentes.html", "2 Análisis de conjuntos frecuentes 2.1 Datos de canastas 2.2 Conjuntos frecuentes 2.3 Monotonicidad de conjuntos frecuentes 2.4 Algoritmo a-priori 2.5 Modelos simples para análisis de canastas 2.6 Soporte teórico y conjuntos frecuentes 2.7 Reglas de asociación 2.8 Dificultades en el análisis de canastas 2.9 Otras medidas de calidad de reglas 2.10 Selección de reglas 2.11 Búsqueda de reglas especializadas 2.12 Visualización de asociaciones 2.13 Otras aplicaciones 2.14 Ejercicios", " 2 Análisis de conjuntos frecuentes Una de las tareas más antiguas de la minería de datos es la búsqueda de conjuntos frecuentes en canastas, o un análisis derivado que se llama análisis de reglas de asociación. Originalmente, pensamos que tenemos una colección grande de tickets de un supermercado. Nos interesa encontrar subconjuntos de artículos (por ejemplo, pan y leche) que ocurren frecuentemente en esos tickets. La idea es que si tenemos estos subconjuntos frecuentes, entonces podemos entender mejor el tipo de compras que hacen los clientes, diseñar mejor promociones y entender potenciales efectos cruzados, reordenar los estantes del supermercado, etc. En general, los conjuntos frecuentes indican asociaciones (y cuantificaciones de la asociación) entre artículos que hay que tomar en cuenta al momento de tomar decisiones. Esto normalmente se llama análisis de market basket. El análisis de subconjuntos frecuentes puede ser utilizado para otros propósitos, como veremos más adelante. 2.1 Datos de canastas Consideremos el siguiente ejemplo chico del paquete arules. Contiene unas \\(10\\) mil canastas observadas en de un supermercado durante un mes, agregadas a \\(169\\) categorías. En muchos casos prácticos, el número de canastas o transacciones puede llegar hasta los miles o millones de millones de transacciones, y el número de artículos puede ser de miles o decenas de miles. data(Groceries) # del paquete arules Groceries ## transactions in sparse format with ## 9835 transactions (rows) and ## 169 items (columns) lista_mb &lt;- as(Groceries, &quot;list&quot;) Estas son tres canastas (tickets) de ejemplo: lista_mb[[2]] ## [1] &quot;tropical fruit&quot; &quot;yogurt&quot; &quot;coffee&quot; lista_mb[[52]] ## [1] &quot;canned beer&quot; lista_mb[[3943]] ## [1] &quot;sausage&quot; &quot;UHT-milk&quot; &quot;flour&quot; &quot;flower (seeds)&quot; Describiremos algunas características típicas de este tipo de datos. En primer lugar, podemos calcular la distribución del número de artículos por canasta, y vemos que es una cantidad relativamente baja en comparación al número total de artículos existentes: sprintf(&quot;Número de canastas: %s&quot;, length(lista_mb)) ## [1] &quot;Número de canastas: 9835&quot; num_items &lt;- sapply(lista_mb, length) sprintf(&quot;Promedio de artículos por canasta: %.3f&quot;, mean(num_items)) ## [1] &quot;Promedio de artículos por canasta: 4.409&quot; qplot(num_items, binwidth = 1) Podemos hacer una tabla con las canastas y examinar los artículos más frecuentes: canastas_tbl &lt;- tibble( canasta_id = 1:length(lista_mb), articulos = lista_mb) canastas_tbl ## # A tibble: 9,835 × 2 ## canasta_id articulos ## &lt;int&gt; &lt;list&gt; ## 1 1 &lt;chr [4]&gt; ## 2 2 &lt;chr [3]&gt; ## 3 3 &lt;chr [1]&gt; ## 4 4 &lt;chr [4]&gt; ## 5 5 &lt;chr [4]&gt; ## 6 6 &lt;chr [5]&gt; ## 7 7 &lt;chr [1]&gt; ## 8 8 &lt;chr [5]&gt; ## 9 9 &lt;chr [1]&gt; ## 10 10 &lt;chr [2]&gt; ## # … with 9,825 more rows canastas_tbl$articulos[[1]] ## [1] &quot;citrus fruit&quot; &quot;semi-finished bread&quot; &quot;margarine&quot; ## [4] &quot;ready soups&quot; num_canastas &lt;- nrow(canastas_tbl) articulos_frec &lt;- canastas_tbl |&gt; unnest(cols = articulos) |&gt; group_by(articulos) |&gt; summarise(n = n()) |&gt; mutate(prop = n / num_canastas) |&gt; arrange(desc(n)) articulos_frec |&gt; mutate(across(where(is_double), ~ round(.x, 3))) |&gt; DT::datatable() ggplot(articulos_frec, aes(x = prop)) + geom_histogram(binwidth = 0.01) + xlab(&quot;Proporción de canastas&quot;) + ylab(&quot;Número de artículos&quot;) Y vemos que hay algunos pocos artículos que ocurren a tasas muy altas en las canastas. La mayoría tiene tasas de ocurrencia baja, y muchos ocurren en una fracción pequeña de las transacciones. Un primer análisis que podríamos considerar es el de canastas completas que ocurren frecuentemente. ¿Qué tan útil crees que puede ser este análisis? colapsar_canasta &lt;- function(x, sep = &quot;-&quot;){ # convierte cada canasta a una cadena x |&gt; as.character() |&gt; sort() |&gt; paste(collapse = &quot;-&quot;) } canastas_conteo &lt;- canastas_tbl |&gt; mutate(canasta_str = map_chr(articulos, colapsar_canasta)) |&gt; group_by(canasta_str) |&gt; summarise(n = n(), .groups = &quot;drop&quot;) |&gt; mutate(prop = round(n /num_canastas, 5)) |&gt; arrange(desc(n)) nrow(canastas_conteo) ## [1] 7011 Y aquí vemos las canastas más frecuentes: DT::datatable(canastas_conteo |&gt; head(n = 100) |&gt; mutate_if(is.numeric, ~ round(.x, 4))) Hay algunas canastas (principalmente canastas que contienen solo un artículo) que aparecen con frecuencia considerable (alrededor de \\(1\\%\\) o \\(2\\%\\)), pero las canastas están bastante dispersas en el espacio de posibles canastas (que es gigantesco: ¿puedes calcularlo?). Debido a esta dispersión este análisis es de utilidad limitada. Datos de canastas El tamaño de las canastas normalmente es chico (por ejemplo de \\(1\\) a \\(30\\) artículos distintos). El número total de artículos típicamente no es muy grande (de cientos a cientos de miles, por ejemplo). El número de canastas puede ser mucho mayor (en algunos casos miles de millones) y quizá no pueden leerse completas en memoria. La mayoría de los artículos ocurre con frecuencias relativamente bajas, aunque unos cuantos tienen frecuencia alta. El número de canastas distintas es alto, y hay pocas canastas frecuentes. El último inciso señala que encontrar canastas frecuentes no será muy informativo. En lugar de eso buscamos conjuntos de artículos (que podríamos llamar subcanastas) que forman parte de muchas canastas. 2.2 Conjuntos frecuentes Un enfoque simple y escalable para analizar estas canastas es el de los conjuntos frecuentes (frequent itemsets). Conjuntos frecuentes Consideramos un conjunto de artículos \\(I = \\{s_1,s_2,\\ldots, s_k\\}\\). El soporte de \\(I\\) lo definimos como la proporción de canastas que contienen (al menos) estos artículos: \\[P(I) = \\frac{n(I)}{n},\\] donde \\(n(I)\\) es el número de canastas que contienen todos los artículos de \\(I\\), y \\(n\\) es el número total de canastas. Sea \\(s\\in (0,1)\\). Para este valor fijo \\(s\\), decimos que un conjunto de artículos \\(I\\) es un conjunto frecuente cuando \\(P(I)\\geq s\\). Ejercicio Considera las canastas {1,2,3}, {1,2}, {2,4}, {2,3}. ¿Cuáles son los itemsets frecuentes de soporte &gt; 0.4? Ejemplo Explicamos más adelante la función apriori de arules, pero por lo pronto podemos examinar algunos conjuntos frecuentes de soporte mínimo \\(0.01\\) (como hay alrededor de \\(10000\\) canastas, esto significa que canastas que aparecieron al menos \\(100\\) veces durante el mes): pars &lt;- list(supp = 0.01, target = &quot;frequent itemsets&quot;) ap &lt;- apriori(lista_mb, parameter = pars) length(ap) ## [1] 333 Veamos algunos conjuntos frecuentes de tamaño \\(1\\): ap_1 &lt;- subset(ap, size(ap) == 1) length(ap_1) ## [1] 88 sort(ap_1, by = &quot;support&quot;) |&gt; DATAFRAME() |&gt; head(10) ## items support count ## 88 {whole milk} 0.25551601 2513 ## 87 {other vegetables} 0.19349263 1903 ## 86 {rolls/buns} 0.18393493 1809 ## 84 {soda} 0.17437722 1715 ## 85 {yogurt} 0.13950178 1372 ## 81 {bottled water} 0.11052364 1087 ## 83 {root vegetables} 0.10899847 1072 ## 82 {tropical fruit} 0.10493137 1032 ## 79 {shopping bags} 0.09852567 969 ## 80 {sausage} 0.09395018 924 Algunas de tamaño \\(2\\) y \\(3\\): ap_2 &lt;- subset(ap, size(ap) == 2) length(ap_2) ## [1] 213 sort(ap_2, by = &quot;support&quot;) |&gt; head(10) |&gt; DATAFRAME() ## items support count ## 301 {other vegetables,whole milk} 0.07483477 736 ## 300 {rolls/buns,whole milk} 0.05663447 557 ## 298 {whole milk,yogurt} 0.05602440 551 ## 291 {root vegetables,whole milk} 0.04890696 481 ## 290 {other vegetables,root vegetables} 0.04738180 466 ## 297 {other vegetables,yogurt} 0.04341637 427 ## 299 {other vegetables,rolls/buns} 0.04260295 419 ## 286 {tropical fruit,whole milk} 0.04229792 416 ## 295 {soda,whole milk} 0.04006101 394 ## 293 {rolls/buns,soda} 0.03833249 377 ap_3 &lt;- subset(ap, size(ap) == 3) length(ap_3) ## [1] 32 sort(ap_3, by=&quot;support&quot;) |&gt; head() |&gt; DATAFRAME() ## items support count ## 327 {other vegetables,root vegetables,whole milk} 0.02318251 228 ## 332 {other vegetables,whole milk,yogurt} 0.02226741 219 ## 333 {other vegetables,rolls/buns,whole milk} 0.01789527 176 ## 322 {other vegetables,tropical fruit,whole milk} 0.01708185 168 ## 331 {rolls/buns,whole milk,yogurt} 0.01555669 153 ## 320 {tropical fruit,whole milk,yogurt} 0.01514997 149 También podemos ver qué itemsets incluyen algún producto particular, por ejemplo ap_berries &lt;- subset(ap, items %pin% &quot;berries&quot;) length(ap_berries) ## [1] 4 sort(ap_berries, by =&quot;support&quot;) |&gt; head() |&gt; DATAFRAME() ## items support count ## 48 {berries} 0.03324860 327 ## 99 {berries,whole milk} 0.01179461 116 ## 97 {berries,yogurt} 0.01057448 104 ## 98 {berries,other vegetables} 0.01026945 101 ap_soda &lt;- subset(ap, items %pin% &quot;soda&quot;) length(ap_soda) ## [1] 28 sort(ap_soda, by =&quot;support&quot;) |&gt; head() |&gt; DATAFRAME() ## items support count ## 84 {soda} 0.17437722 1715 ## 295 {soda,whole milk} 0.04006101 394 ## 293 {rolls/buns,soda} 0.03833249 377 ## 294 {other vegetables,soda} 0.03274021 322 ## 276 {bottled water,soda} 0.02897814 285 ## 292 {soda,yogurt} 0.02735130 269 Observaciones: Si hay \\(m\\) artículos, entonces el número de posibles itemsets es de \\(2^m -1\\). Este es un número típicamente muy grande. En nuestro ejemplo, existen unos \\(7\\times 10^{50}\\) posibles itemsets. El número de itemsets de un tamaño fijo, por ejemplo \\(k=5\\), también puede ser muy grande ( \\(169 \\choose 5\\) es del orden de mil millones). Si existe un gran número canastas, contar todas las posibles subcanastas que ocurren es poco factible si lo hacemos por fuerza bruta: requeríamos usar tablas en disco que son relativamente lentas, y quizá no podremos mantener en memoria todos los conteos. Sin embargo, en el ejemplo de arriba encontramos solamente 333 itemsets frecuentes: este número es relativamente chico comparado con el número de posibles itemsets. Esto nos da indicios que contando de una manera apropiada puede ser posible encontrar todos los itemsets frecuentes de cualquier orden. Ejemplo Si reducimos el soporte a \\(0.0001\\) (que implica prácticamente que queremos contar todos los itemsets que ocurren), obtenemos: pars_2 &lt;- list(supp = 0.0001, target=&quot;frequent itemsets&quot;, maxtime = 0, maxlen = 6) ap_todos &lt;- apriori(lista_mb, parameter = pars_2) ## Apriori ## ## Parameter specification: ## confidence minval smax arem aval originalSupport maxtime support minlen ## NA 0.1 1 none FALSE TRUE 0 1e-04 1 ## maxlen target ext ## 6 frequent itemsets TRUE ## ## Algorithmic control: ## filter tree heap memopt load sort verbose ## 0.1 TRUE TRUE FALSE TRUE 2 TRUE ## ## Absolute minimum support count: 0 ## ## set item appearances ...[0 item(s)] done [0.00s]. ## set transactions ...[169 item(s), 9835 transaction(s)] done [0.00s]. ## sorting and recoding items ... [169 item(s)] done [0.00s]. ## creating transaction tree ... done [0.00s]. ## checking subsets of size 1 2 3 4 5 6 ## Warning in apriori(lista_mb, parameter = pars_2): Mining stopped (maxlen ## reached). Only patterns up to a length of 6 returned! ## done [1.59s]. ## sorting transactions ... done [0.00s]. ## writing ... [10945131 set(s)] done [1.82s]. ## creating S4 object ... done [2.54s]. Entonces el número de itemsets que obtenemos (longitud menor o igual a \\(5\\)) es length(ap_todos) ## [1] 10945131 que es órdenes de magnitud más grande que el conjunto de todas las transacciones. En este ejemplo chico, el cálculo de esta colección (hasta canastas de tamaño 6) puede requierir menos de unos 2Gb de memoria (8Gb pueden no son ser suficientes para encontrar los de tamaño \\(8\\), \\(9\\) y \\(10\\)). Puedes ver entonces que para conjuntos de transacciones masivos, contar todos los itemsets generalmente será un proceso muy lento si no es que más bien infactible. 2.3 Monotonicidad de conjuntos frecuentes Consideramos el problema de encontrar los conjuntos frecuentes. Como discutimos arriba en las características de los datos de canastas, suponemos que La lista de transacciones es muy grande, y no puede leerse completa en memoria, Sin embargo, para una sola canasta, es posible calcular de manera relativamente rápida todos los subconjuntos de tamaño \\(k\\) (para \\(k=1,2,3,4\\), por ejemplo). Por ejemplo, si una canasta tiene \\(10\\) artículos, hay \\(\\binom{10}{3}\\) subcanastas de tamaño 3, \\(\\binom{10}{3} = 210\\). Calcular estos subconjuntos es relativamente rápido comparado con leer de disco una transacción. Finalmente, suponemos que el número de itemsets frecuentes es relativamente chico, debido a que el número de articulos que son más frecuentes es relativamente bajo (lo cual también depende de que escojamos un soporte suficientemente alto). Bajo estas características, el principio básico que hace posible hacer los conteos de itemsets frecuentes es el siguiente: Monotonicidad de itemsets Sea \\(s\\) un nivel de soporte mínimo fijo. Si un itemset \\(I\\) es frecuente, entonces todos sus subconjuntos son itemsets frecuentes. Equivalentemente, si algún subconjunto de un itemset no es frecuente, entonces el itemset no puede ser frecuente. Así que a priori, no es necesario examinar o contar itemsets que contienen al menos un subconjunto que no sea frecuente. Este hecho, junto con la selección de un soporte mínimo para los itemsets frecuentes, es el que hace que la búsqueda y conteo de itemsets frecuentes sea un problema factible, pues podemos descartar una gran cantidad de artículos o itemsets a priori de manera simple, y no es necesario contar todo. La demostración es como sigue: Sea \\(n(I)\\) el número de canastas que contiene \\(I\\), y supongamos que \\(\\tfrac{n(I)}{n}&gt;s\\) (\\(I\\) es un conjunto frecuente). Sea ahora \\(J\\subset I\\). Entonces cualquier canasta que contiene los artículos de \\(I\\) contiene también los artículos de \\(J\\) (que son menos), de forma que \\(n(J)\\geq n(I)\\). Como \\(\\tfrac{n(I)}{n}&gt;s\\), entonces \\(J\\) es un conjunto frecuente. Ejemplo En nuestro ejemplo anterior, el número total de itemsets de tamaño \\(2\\) es length(subset(ap_todos, size(ap_todos) == 2)) ## [1] 9636 Comparamos con los pares frecuentes cuando el soporte es \\(1\\%\\): length(subset(ap, size(ap) == 2)) ## [1] 213 una diferencia de casi dos ordenes de magnitud. 2.4 Algoritmo a-priori Para entender cómo aplicamos monotonicidad, consideremos cómo calcularíamos los pares frecuentes. Primero calculamos los artículos frecuentes (itemsets de tamaño \\(1\\)), que son los artículos que aparecen en al menos una proporción \\(s\\) de las canastas. (Contar candidatos) Esto requiere recorrer el archivo de transacciones y contar todos los artículos. (Podar) Examinamos los conteos y seleccionamos aquellos artículos que son frecuentes. Por el principio de monotonicidad, ningún par frecuente puede contener un artículo no frecuente. Así que para calcular pares: (Contar candidatos) Recorremos el archivo de transacciones. Para cada transacción, solo contamos pares candidatos cuyos dos artículos son artículos frecuentes (del paso anterior) (Podar) Examinamos los conteos y seleccionamos aquellos pares que son frecuentes. Nótese que este algoritmo requiere dos pasadas sobre el conjunto de transacciones. Ejercicio Aplica este algoritmo para las canastas {1,2,3}, {1,8}, {2,4}, {2,3,6,7,8}, {2,3,8}, {1,7,8}, {1,2,3,5}, {2,3}. (soporte &gt; 0.3) Observaciones En este algoritmo, no es necesario leer todas las transacciones a la vez, podemos procesarlas por bloques, por ejemplo. Usamos una pasada de los datos para cada tamaño de itemset frecuente. En la primera pasada del algoritmo (artículos frecuentes), típicamente no es un problema mantener el conteo de todos los artículos en memoria (hay relativamente pocos artículos). Si en la segunda pasada no usáramos monotonicidad, tendríamos que mantener conteos de todos los posibles pares (que son del orden \\(m^2\\), donde \\(m\\) es el número de artículos). Mantener este conteo en memoria podría ser difícil si el número de artículos es grande. Sin embargo, el número de artículos frecuentes generalmente es considerablemente menor. Para itemsets de tamaño más grande, el algoritmo original a priori (Agrawal and Srikant 1994) es: Algoritmos a-priori Sea \\(L_1\\) el conjunto de itemsets frecuentes de tamaño 1. Para obtener \\(L_k\\), el conjunto de itemsets frecuentes de tamaño \\(k\\): Sea \\(C_k\\) el conjunto de candidatos de tamaño \\(k\\), construido a partir de \\(L_{k-1}\\) (monotonicidad). Para cada transacción \\(t\\), Calculamos \\(S_t\\), que son los candidatos en \\(C_k\\) que están en \\(t\\). Agregamos 1 a cada conteo de los candidatos en \\(S_t\\). Filtramos los elementos de \\(C_k\\) que tengan conteo mayor que el soporte definido para obtener \\(L_k\\) Seguimos hasta que encontramos que algún \\(L_k\\) es vacío (no hay itemsets frecuente), o para alguna \\(k\\) fija. Observaciones: Este algoritmo se puede implementar de distintas maneras, por ejemplo: Hay distintas maneras de generar el conjunto \\(C_{k}\\) de candidatos. El paper original sugiere (suponiendo que los artículos siempre están ordenados en los itemsets) hacer un join de \\(L_{k-1}\\) consigo misma. Por ejemplo, para generar los tríos candidatos \\(C_3\\) a partir de \\(L_2\\) hacemos SELECT A.item1, A.item2, B.item2 FROM L2 AS A, L2 AS B WHERE A.item1 = B.item1, A.item2 &lt; B.item2 donde los itemsets estén ordenados en las canastas (por índice o lexicográficamente). Hay también distintas maneras de calcular \\(C_t\\) para cada transacción. El paper original sugiere una estructura de árbol para encontrar los subconjuntos de \\(t\\) que están en \\(C_k\\), y no es neceasrio calcular \\(C_k\\). Ver también (Borgelt 2004). Más detalles de la implementación de los algoritmos (incluyendo algunos más modernos como FPGrowth, que está implementado en spark) se puede encontrar en (Leskovec, Rajaraman, and Ullman 2014) y en (Borgelt 2004). FPGrowth construye una representación eficiente de árbol para los itemsets frecuentes y con esto evita el paso de construcción de candidatos (aunque tiene que mantener en memoria el árbol, que puede ser una estructura grande). 2.5 Modelos simples para análisis de canastas Podemos entender mejor el comportamiento de este análisis con algunos modelos simples para datos de canastas. En primer lugar, pensamos que los datos están en forma de codificación dummy (aunque no usemos esta representación para los datos reales, podemos considerarlo teóricamente). Una canasta es entonces un renglón de ceros y unos, dependendiendo qué artículos están o no en la canasta: \\[X= (X_1,X_2,\\ldots, X_m)\\] donde \\(X_i = 1\\) si el artículo \\(i\\) está en la canasta, y \\(X_i=0\\) si no está. Podríamos pensar entonces en construir modelos para la conjunta de las canastas \\[P(X_1=x_1,X_2=x_2,\\ldots, X_m=x_m)\\] Ejemplo Por ejemplo, si los items son 1-camisa, 2-pantalones, 3-chamarra, podríamos tener las dos transacciones \\(X = (1,0,0)\\), para alguien que solo compró una camisa \\(X = (1,0,1)\\), para alguien que solo compró camisa y chamarra Y podemos inventar una conjunta para todas las canastas, por ejemplo ## # A tibble: 8 × 4 ## p c ch prob ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 0 0 0 ## 2 0 0 1 0.105 ## 3 0 1 0 0.186 ## 4 0 1 1 0.186 ## 5 1 0 0 0.186 ## 6 1 0 1 0.186 ## 7 1 1 0 0.105 ## 8 1 1 1 0.047 A partir de esta conjunta podemos calcular cualquier probabilidad que nos interese. Por ejemplo, la probabilidad de que alguien compre una camisa dado que compró un pantalón es: prob_cp &lt;- filter(probs, p == 1 &amp; c == 1) |&gt; pull(prob) |&gt; sum() prob_p &lt;- filter(probs, p == 1) |&gt; pull(prob) |&gt; sum() (prob_cp / prob_p) |&gt; round(2) ## [1] 0.29 Como discutimos arriba, intentar estimar esta conjunta usando simples conteos de canastas no funciona, pues hay \\(2^n\\) posibles canastas, e incluso cuando \\(n\\) no es tan grande (por ejemplo \\(200\\)) es un número muy grande. Tenemos dos caminos (o una combinación de ellos): podemos hacer supuestos acerca de esta conjunta (y checar si son apropiados), o concentrarnos en estimar solamente algunas de sus características. Más adelante veremos algunas técnicas basadas en modelos (por ejemplo embeddings de productos y canastas) que pueden ser útiles para el problema de encontrar asociaciones entre artículos. Por el momento, en market basket tomamos el segundo camino: estimar sólo algunas cantidades de la conjunta de ocurrencia de artículos. La simplificación de market basket es concentrarnos en algunas marginales que involucren a pocos artículos de esta distribución, que tienen una forma como \\[P(X_{i}=1,X_{j}=1),\\] que es la probabilidad de que el conjunto \\({i,j}\\) aparezca en una canasta dada, o en los términos de market basket, el soporte del itemset \\({i,j}\\). La búsqueda de itemsets frecuentes se traduce entonces en buscar marginales de este tipo que no involucren muchas variables y que tengan valores altos - buscamos modas en las marginales de la distribución de las canastas. Modelo de artículos independientes Por otro lado, si hacemos supuestos acerca de la conjunta es posible ajustar modelos a los datos de canastas. En primer lugar, podemos considerar el modelo simplista que establece que la aparición o no de cada artículo es independiente del resto: \\[P(X_1=x_1,\\ldots, X_m=x_m) =\\prod_m P(X_j=x_j)\\] Y adicionalmente, suponemos que la probabilidad de cada artículo es fija dada por \\[P(X_j=1)=p_j\\]. Este modelo no es realista, pero podemos usarlo para entender algunos aspectos de nuestros algoritmos de conjuntos frecuentes. El soporte (bajo el modelo teórico) de un conjunto de \\(k\\) artículos es \\[P(X_{s_1}=1,X_{s_2}=1,\\ldots, X_{s_k}=1)=p_{s_1}p_{s_2}\\cdots p_{s_k}\\] Podemos ver qué pasa si simulamos transacciones bajo este modelo simple. Primero definimos una función para simular canastas con probabilidades dadas para los artículos simular_transacciones &lt;- function(n_items, n_trans, prob){ etiquetas &lt;- names(prob) canastas &lt;- map(seq(1, n_trans), function(i){ seleccion &lt;- rbinom(n_items, 1, prob = prob) etiquetas[seleccion == 1] }) canastas } Y ahora simulamos usando las proporciones que encontramos en el conjunto Groceries set.seed(1299) probs_items &lt;- itemFrequency(Groceries) |&gt; sort() trans &lt;- simular_transacciones(n_items = 169, n_trans = 10000, prob = probs_items) ap_indep &lt;- apriori(trans, parameter = list(support = 0.005, target = &quot;frequent itemsets&quot;), control = list(verbose = FALSE)) Por ejemplo, aquí vemos algunos pares frecuentes encontrados por el algoritmo: inspect(subset(ap_indep, support &gt; 0.015 &amp; size(ap_indep)==2)) ## items support count ## [1] {beef, whole milk} 0.0151 151 ## [2] {margarine, whole milk} 0.0160 160 ## [3] {butter, whole milk} 0.0159 159 ## [4] {pork, whole milk} 0.0172 172 ## [5] {domestic eggs, whole milk} 0.0165 165 ## [6] {brown bread, whole milk} 0.0186 186 ## [7] {other vegetables, whipped/sour cream} 0.0159 159 ## [8] {whipped/sour cream, whole milk} 0.0177 177 ## [9] {fruit/vegetable juice, whole milk} 0.0182 182 ## [10] {pip fruit, whole milk} 0.0195 195 ## [11] {canned beer, rolls/buns} 0.0158 158 ## [12] {canned beer, other vegetables} 0.0160 160 ## [13] {canned beer, whole milk} 0.0203 203 ## [14] {newspapers, rolls/buns} 0.0150 150 ## [15] {newspapers, other vegetables} 0.0171 171 ## [16] {newspapers, whole milk} 0.0206 206 ## [17] {bottled beer, rolls/buns} 0.0151 151 ## [18] {bottled beer, other vegetables} 0.0158 158 ## [19] {bottled beer, whole milk} 0.0209 209 ## [20] {other vegetables, pastry} 0.0192 192 ## [21] {pastry, whole milk} 0.0216 216 ## [22] {citrus fruit, soda} 0.0151 151 ## [23] {citrus fruit, rolls/buns} 0.0167 167 ## [24] {citrus fruit, other vegetables} 0.0177 177 ## [25] {citrus fruit, whole milk} 0.0240 240 ## [26] {sausage, soda} 0.0179 179 ## [27] {rolls/buns, sausage} 0.0170 170 ## [28] {other vegetables, sausage} 0.0194 194 ## [29] {sausage, whole milk} 0.0250 250 ## [30] {shopping bags, soda} 0.0172 172 ## [31] {rolls/buns, shopping bags} 0.0150 150 ## [32] {other vegetables, shopping bags} 0.0182 182 ## [33] {shopping bags, whole milk} 0.0258 258 ## [34] {soda, tropical fruit} 0.0180 180 ## [35] {rolls/buns, tropical fruit} 0.0193 193 ## [36] {other vegetables, tropical fruit} 0.0209 209 ## [37] {tropical fruit, whole milk} 0.0266 266 ## [38] {root vegetables, soda} 0.0184 184 ## [39] {rolls/buns, root vegetables} 0.0183 183 ## [40] {other vegetables, root vegetables} 0.0191 191 ## [41] {root vegetables, whole milk} 0.0294 294 ## [42] {bottled water, yogurt} 0.0177 177 ## [43] {bottled water, soda} 0.0202 202 ## [44] {bottled water, rolls/buns} 0.0218 218 ## [45] {bottled water, other vegetables} 0.0227 227 ## [46] {bottled water, whole milk} 0.0287 287 ## [47] {soda, yogurt} 0.0228 228 ## [48] {rolls/buns, yogurt} 0.0245 245 ## [49] {other vegetables, yogurt} 0.0258 258 ## [50] {whole milk, yogurt} 0.0334 334 ## [51] {rolls/buns, soda} 0.0345 345 ## [52] {other vegetables, soda} 0.0344 344 ## [53] {soda, whole milk} 0.0452 452 ## [54] {other vegetables, rolls/buns} 0.0342 342 ## [55] {rolls/buns, whole milk} 0.0462 462 ## [56] {other vegetables, whole milk} 0.0507 507 Estos pares frecuentes no se deben a asociaciones entre los artículos, sino a co-ocurrencia en las canastas. Artículos frecuentes apareceran en pares frecuentes, tríos frecuentes, etc. Comparamos por ejemplo el número de reglas encontradas para los datos reales, contra 20 simulaciones de este modelo: # parámetros de apriori pars &lt;- list(supp = 0.005, target=&quot;frequent itemsets&quot;) # producir 10 simulaciones replicaciones &lt;- map(1:20, function(i){ trans &lt;- simular_transacciones(n_items = 169, n_trans = 10000, prob = probs_items) ap_indep &lt;- apriori(trans, parameter = pars, control = list(verbose = FALSE)) conteos &lt;- table(size(ap_indep)) tibble(rep = i, long = names(conteos), n = as.numeric(conteos)) }) reps_tbl &lt;- bind_rows(replicaciones) Ahora vamos a comparar con el análisis de las canastas reales: # calcular observados ap &lt;- apriori(lista_mb, parameter = pars, control = list(verbose = FALSE)) conteos_obs &lt;- table(size(ap)) obs_tbl &lt;- tibble(long = names(conteos_obs), n = as.numeric(conteos_obs)) ggplot(reps_tbl, aes(x = long, y = n)) + geom_jitter(height = 0) + geom_point(data = obs_tbl, colour = &quot;red&quot;, size = 2) + labs(x = &quot;Tamaño&quot;) Y vemos claramente que el modelo simple está lejos de ajustar los datos que observamos en las canastas de Groceries. Hay muchas más combinaciones frecuentes de tamaño \\(2\\) y \\(3\\) de lo que esperaríamos si los artículos se compraran independientemente, y esto indica asociaciones positivas entre artículos que nos gustaría descubrir. Veremos más adelante cómo identificar este tipo de conjuntos frecuentes. Finalmente, comparamos los itemsets de ambos casos: coinciden &lt;- match(ap, ap_indep) ## Warning in match(x@items, table@items, nomatch = nomatch, incomparables = ## incomparables): Item coding not compatible, recoding item matrices first. coinciden[500:505] ## [1] 323 324 325 NA NA NA inspect(ap[500]) ## items support count ## [1] {pork, rolls/buns} 0.01128622 111 inspect(ap_indep[323]) ## items support count ## [1] {pork, rolls/buns} 0.011 110 sum(!is.na(coinciden)) # contar los matches ## [1] 491 length(ap) ## [1] 1001 length(ap_indep) ## [1] 521 Y vemos que en el análisis de datos reales estamos capturando la mayor parte de los itemsets frecuentes del modelo independiente. Estos itemsets se explican por la frecuencia simple de aparición de cada artículo. 2.6 Soporte teórico y conjuntos frecuentes El tamaño de los datos de transacciones está relacionado con los mínimos soportes que tiene sentido analizar. Supongamos por ejemplo que tenemos un conjunto de \\(n\\) transacciones, y buscamos soporte mínimo de \\(s\\). Consideramos entonces que un conjunto \\(I\\) tiene soporte \\(s_I\\) teórico (el que observaríamos con una muestra muy grande), y nuestro interés es ver qué tan bien podemos identificar como frecuentes aquellos conjuntos que satisfagan \\(s_I &gt; s\\). Notamos primero que el valor esperado de ocurrencias \\(n(I)\\) de un conjunto \\(I\\) en los tiene una distribución binomial con número de pruebas \\(n\\) y probabilidad de observar un éxito de \\(s_I\\). Si suponemos que \\(ns_I \\leq 1\\) y \\(n\\) no es muy chico, entonces la probabilidad de observar \\(I\\) 0 veces es aproximadamente tab_1 &lt;- tibble(ns = seq(0.1, 1, 0.2)) |&gt; mutate(prob_no_obs = ppois(0, ns)) tab_1 ## # A tibble: 5 × 2 ## ns prob_no_obs ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0.1 0.905 ## 2 0.3 0.741 ## 3 0.5 0.607 ## 4 0.7 0.497 ## 5 0.9 0.407 De forma que con valores de \\(n\\) y \\(s\\) tales que \\(ns &lt;1\\) , típicamente no observaremos una buena parte de todos los conjuntos frecuentes que buscamos encontrar. Supongamos entonces que \\(ns\\geq 5\\), y queremos aproximar la probabilidad de encontrar una canasta \\(I\\) tal que \\(s_I = (1+\\alpha) s\\) (es decir, canastas con soporte de al menos \\(\\alpha\\)% más que el soporte mínimo elegido). Entonces usando la aproximación normal a la binomial, la probabilidad de capturar a \\(I\\) correctamente como frecuente es aproximadamente \\[P \\left (Z &gt; \\frac{\\sqrt{n}(s - s_I)}{\\sqrt{s_I(1-s_I)}} \\right ) = P \\left (Z &gt; \\frac{\\sqrt{n}(s - (1+\\alpha)s)}{\\sqrt{s_I(1-s_I)}} \\right )\\approx P \\left (Z &gt; -\\frac{\\alpha}{\\sqrt{1+\\alpha}}\\sqrt{ns}\\right )\\] crossing(ns = seq(5, 100, 5), alpha = c(0.10, 0.15, 0.20, 0.25)) |&gt; mutate(prob_capturar = map2_dbl(ns, alpha, \\(ns, alpha) pnorm(sqrt(ns) * alpha/sqrt(1-alpha)))) |&gt; ggplot(aes(x = ns, y = prob_capturar, colour = factor(alpha))) + geom_line() + geom_point() + ylab(&quot;Recall/Sensibilidad&quot;) Como ejercicio, puedes calcular la probabilidad de capturar incorrectamente como frecuente un conjunto \\(I\\) con \\(s_I = s/(1+\\alpha)\\) (la tasa de falsos positivos). En general, vemos que tomar \\(ns\\) menor que 10 no necesariamente es buena idea Así que si queremos capturar con probabilidad al menos 90% las canastas cuyo soporte es 20% mayor al soporte mínimo, necesitamos tomar \\(s\\) tal que \\(ns&gt;30\\), por ejemplo. Usualmente queremos hacer el soporte mínimo \\(s\\) un poco más chico, para que capturemos con alta probabilidad aquellos conjuntos de soporte teórico \\(s\\) (aunque esto implica también que capturaremos más conjuntos de menor soporte que el teórico). La elección de punto de corte es más o menos arbitraria (lo cual es una dificultad del análisis de conjuntos frecuentes), pero es importante recordar que si hacemos \\(s\\) mucho más chico que estas recomendaciones, capturaremos por azar muchos conjuntos cuya frecuencia teórica es mucho más baja de lo que esperábamos. Finalmente, recordamos que cuanto más chico tomemos el soporte, más conjuntos frecuentes encontraremos, y el procesamiento puede tomar mucho tiempo. Ejemplo Podemos experimentar con el modelo de independencia: simular_num_reglas &lt;- function(n_trans, prob, pars){ n_items &lt;- length(prob) etiquetas &lt;- 1:n_items if(!is.null(names(prob))) { etiquetas &lt;- names(prob) } trans &lt;- map(1:n_trans, function(i){ etiquetas[which(rbinom(n_items, 1, prob = prob) == 1)] }) ap_indep &lt;- apriori(trans, parameter = pars, control = list(verbose = FALSE)) conteos &lt;- table(size(ap_indep)) tibble(long = names(conteos), n = as.numeric(conteos)) } # fijamos para el ejemplo probs_items &lt;- sort(itemFrequency(Groceries)) pars_1 &lt;- list(support = 0.005, target = &quot;frequent itemsets&quot;) simular_1 &lt;- function(n_trans){ sim_tbl &lt;- simular_num_reglas(n_trans = n_trans, prob = probs_items, pars = pars_1) sim_tbl } set.seed(125) n_trans &lt;- c(10, 25, 50, 100, 200, 400, 800, 1600, 3200, 6400, 12800, 25600, 51200) reps &lt;- tibble(n_trans = rep(n_trans, each = 5)) |&gt; mutate(conteos = map(n_trans, simular_1)) |&gt; mutate(ns = n_trans * 0.005) reps_long_2 &lt;- reps |&gt; unnest(cols = conteos) |&gt; filter(long == 2) ggplot(reps_long_2, aes(x=factor(ns), y = n)) + geom_boxplot() + ylab(&quot;Número de conjuntos frecuentes detectados (k=2)&quot;) + xlab(&quot;Soporte crudo (ns)&quot;) + labs(subtitle = &quot;Soporte min 0.005&quot;) Observaciones Para conjuntos de transacciones chicos no podemos capturar muchos conjuntos frecuentes teóricos porque no observamos suficientes transacciones. Para niveles medios de número de transacciones, podemos obtener resultados ruidosos: muchos subconjuntos que identificamos como frecuentes no lo son realmente (es variación muestral). Cuanto tenemos un número suficientemente alto de transacciones, el número de subconjuntos frecuentes encontrados se estabiliza en el valor teórico verdadero del número de conjuntos frecuentes que existen. 2.7 Reglas de asociación Aunque algunas veces lo único que nos interesa es la co-ocurrencia de artículos (por ejemplo, para entender qué artículos se podrían ver potencialmente afectados por acciones en otros artículos que están en el mismo itemset frecuente), otras veces nos interesa entender qué artículos están asociados a lo largo de canastas por otros factores, como tipo de cliente, tipo de ocasión o propósito (por ejemplo, hora del día, hacer un pastel, promociones, decisiones de organización de estantes), etc. Con este propósito podemos organizar la información de los itemsets frecuentes en términos de reglas de asociación. Un ejemplo de una regla de asociación es: Entre las personas que compran leche y pan, un \\(40\\%\\) compra también yogurt Una regla de asociación es una relación de la forma \\(I\\to j\\), donde \\(I\\) es un conjunto de artículos (el antecedente) y \\(j\\) es un artículo (el consecuente). Definimos la confianza de esta regla como \\[\\hat{P}(I\\to j) = \\hat{P}(j|I) = \\frac{n(I\\cup {j})}{n(I)} = \\hat{P}(I\\cup j)/\\hat{P}(I), \\] es decir, la proporción de canastas que incluyen al itemset \\(I\\cup {j}\\) entre las canastas que incluyen al itemset \\(I\\). La confianza siempre está entre 0 y 1. Observaciones: Por monotonicidad, si \\(J\\) es un conjunto de artículos más grande que \\(I\\) (es decir \\(I\\subset J\\)), entonces \\(n(J) \\leq n(I)\\): cualquier canasta que contiene a \\(J\\) también contiene a \\(I\\), y puede haber algunas canastas que contienen a \\(I\\) no contienen a \\(J\\). Bajo el modelo de items independientes, todas las confianzas satisfacen \\(P(I\\to j)=P(j)\\) (la confianza simplemente es la probabilidad de observar el artículo \\(j\\), independientemente del antecedente). Confianza alta no necesariamente significa una asociación de los items: si el consecuente \\(j\\) tiene soporte alto, entonces podemos obtener confianza alta aunque no haya asociación. Ejemplo En nuestro ejemplo anterior, el soporte de {whole milk,yogurt} es de \\(0.0560\\), el soporte de {whole milk} es \\(0.2555\\), así que la confianza de la regla \\(whole milk \\to yogurt\\) es \\(\\frac{0.0560}{0.2555}=\\) 0.22 Podemos usar la confianza para filtrar reglas que tienen alta probabilidad de cumplirse: Ejemplo pars &lt;- list(supp = 0.01, confidence = 0.20, target=&quot;rules&quot;, ext = TRUE, minlen = 2) reglas &lt;- apriori(lista_mb, parameter = pars) Podemos examinar algunas de las reglas: inspect(reglas[1:10,]) ## lhs rhs support confidence coverage ## [1] {hard cheese} =&gt; {whole milk} 0.01006609 0.4107884 0.02450432 ## [2] {butter milk} =&gt; {other vegetables} 0.01037112 0.3709091 0.02796136 ## [3] {butter milk} =&gt; {whole milk} 0.01159126 0.4145455 0.02796136 ## [4] {ham} =&gt; {whole milk} 0.01148958 0.4414062 0.02602949 ## [5] {sliced cheese} =&gt; {whole milk} 0.01077783 0.4398340 0.02450432 ## [6] {oil} =&gt; {whole milk} 0.01128622 0.4021739 0.02806304 ## [7] {onions} =&gt; {other vegetables} 0.01423488 0.4590164 0.03101169 ## [8] {onions} =&gt; {whole milk} 0.01209964 0.3901639 0.03101169 ## [9] {berries} =&gt; {yogurt} 0.01057448 0.3180428 0.03324860 ## [10] {berries} =&gt; {other vegetables} 0.01026945 0.3088685 0.03324860 ## lift count ## [1] 1.607682 99 ## [2] 1.916916 102 ## [3] 1.622385 114 ## [4] 1.727509 113 ## [5] 1.721356 106 ## [6] 1.573968 111 ## [7] 2.372268 140 ## [8] 1.526965 119 ## [9] 2.279848 104 ## [10] 1.596280 101 En la siguiente tabla, coverage es el soporte del antecedente (lhs = left hand side). Agregamos también el error estándar de la estimación de confidence (que es una proporción basada en el número de veces que se observa el antecedente): df_1 &lt;- sort(reglas, by = &quot;confidence&quot;) |&gt; DATAFRAME() df_2 &lt;- df_1 |&gt; select(LHS, RHS, coverage, confidence, support) |&gt; head(100) |&gt; mutate(lhs.base = num_canastas * coverage) |&gt; mutate(conf.ee = sqrt(confidence * (1 - confidence) / lhs.base)) |&gt; mutate_if(is.numeric, ~ round(.x, 2)) DT::datatable(df_2 |&gt; select(-lhs.base)) Observaciones: Nota que estas tres cantidades están ligadas en cada canasta por \\(coverage\\times confidence = support\\). Usa un argumento de probabilidad condicional para mostrarlo. Muchas de las reglas con confianza alta tienen como consecuente un artículo de soporte alto (por ejemplo, whole milk), como explicamos arriba. Nótese también que las reglas con confianza más alta tienden a tener soporte bajo. Esto lo discutiremos más adelante. Ejercicio Para un mismo consecuente (por ejemplo whole milk), examina cómo varían los valores de confidence. ¿A qué crees que se deba esto? Es natural que artículos frecuentes ocurran en muchas canastas juntas, es decir, que reglas formadas con ellas tengan confianza relativamente alta. Por ejemplo, la regla pan -&gt; verduras podría tener confianza y soporte alto, pero esto no indica ninguna asociación especial entre estos artículos. La razón puede ser que verduras es un artículo muy común. Podemos refinar las reglas de asociación considerando qué tan diferente es \\(P(j|I)\\) de \\(P(j)\\). La primera cantidad es la probabilidad de observar el item \\(j\\) bajo la información de que la canasta contiene a \\(I\\). Si esta cantidad no es muy diferente a \\(P(j)\\), entonces consideramos que esta regla no tiene mucho interés. El lift o intéres de una regla \\(I\\to j\\) se define como \\[L(I\\to j) = \\frac{\\hat{P}({j}|I)}{\\hat{P}({j})},\\] es decir, la confianza de la regla \\(I\\to j\\) dividida entre la proporción de canastas que contienen \\(j\\). En nuestro ejemplo, veamos dos reglas con interés muy distinto: df_1 &lt;- arrange(df_1, desc(lift)) df_1[c(4, nrow(df_1)),] |&gt; select(LHS, RHS, coverage, confidence, lift) ## LHS RHS coverage confidence lift ## 4 {beef} {root vegetables} 0.05246568 0.3313953 3.0403668 ## 231 {soda} {whole milk} 0.17437722 0.2297376 0.8991124 La primera regla tiene un interés mucho más alto que la segunda, lo que indica una asociación más importante entre los dos artículos. Observaciones Cuando decimos que un grupo de artículos están asociados, generalmente estamos indicando que forma alguna regla de asociación con lift alto. En principio también podría haber reglas con lift muy por debajo de uno, y eso también indica una asociación (por ejemplo coca y pepsi). Pero el método de itemsets frecuentes no es muy apropiado para buscar estas reglas, pues precisamente esas reglas tienden a tener soporte y confianza bajas. El valor del lift también puede escribirse (deméstralo) como \\[ \\frac{\\hat{P}(I\\cup\\{j\\})}{\\hat{P}(I)\\hat{P}({j})},\\] Cuando los artículos son independientes, esta cantidad está cercana a \\(1\\). Es una medida de qué tan lejos de independencia están la ocurrencia de los itemsets \\(I\\) y \\(j\\). Ejemplo df_1 &lt;- sort(reglas, by = &quot;lift&quot;) |&gt; DATAFRAME() En esta tabla, coverage es el soporte del antecedente (lhs = left hand side): df_2 &lt;- df_1 |&gt; select(LHS, RHS, coverage, lift, confidence, support) |&gt; head(100) |&gt; mutate_if(is.numeric, ~ round(.x, 2)) DT::datatable(df_2) Las reglas de asociación se calculan comenzando por calcular los itemsets frecuentes según el algoritmo a priori explicado arriba. Para encontrar las reglas de asociación hacemos: Para cada itemset frecuente \\(f\\), tomamos como candidatos a consecuentes los artículos \\(i\\) de \\(f\\) Si la confianza \\(\\frac{\\hat{P}(I)}{\\hat{P}(I-\\{j\\})}\\) es mayor que la confianza mínima, agregamos la regla de asociación \\(I\\to j\\). Con este proceso encontramos todas las reglas \\(I\\to j\\) tales que \\(I\\cup\\{j\\}\\) es un itemset frecuente. 2.8 Dificultades en el análisis de canastas El análisis de canastas es un método rápido y simple que nos da varias maneras de explorar las relaciones entre los artículos. Sin embargo, hay varias dificultades en su aplicación. Número de reglas y itemsets Muchas veces encontramos un número muy grande de itemsets o reglas. Hay varias maneras de filtrar estas reglas según el propósito. Si filtramos mucho, perdemos reglas que pueden ser interesantes. Si filtramos poco, es difícil entender globalmente los resultados del análisis. Un punto de vista es producir una cantidad de reglas para procesar posteriormente con queries: por ejemplo, si nos interesa entender las relaciones de berries con otros artículos, podemos filtrar las reglas encontradas y examinarlas más fácilmente. Cortes estrictos en el filtrado Cuando seleccionamos valores mínimos de soporte, confianza y/o lift, estas decisiones son más o menos arbitrarias. Distintos analistas pueden llegar a resultados distintos, incluso cuando el propósito del análisis sea similar, y en ocasiones hay que iterar el análisis para encontrar valores adecuados que den conjuntos razonables con resultados interesantes. Este último concepto es subjetivo. Redundancia de reglas Existe alguna redundancia en las reglas que encontramos. Por ejemplo, podríamos tener {yogurt, berries} -&gt; {whipped cream}, pero también {yogurt} -&gt; {whipped cream}. Este traslape de reglas hace también difícil entender conjuntos grandes de reglas. Variabilidad de medidas de calidad Un problema del análisis clásico de soporte-confianza-lift es la variabilidad de las estimaciones de confianza y lift. Cuando comenzamos poniendo valores de soporte y confianza relativamente bajos, encontramos muchas reglas. Muchas de estas reglas son ruidosas (en un número más grande de transacciones las descalificaríamos). Intentamos muchas veces filtrar u ordenar por lift, para considerar las reglas más interesantes Sin embargo, encontramos entonces que muchas reglas de lift y/o confianza altas son aquellas que tienen soporte bajo y consecuentes poco frecuentes. Como veremos más adelante, esto se debe muchas veces a error de estimación. Los valores más grandes de lift generalmente son sobreestimaciones, por la naturaleza del análisis basado en cortes. Si regresamos a incrementar soporte y confianza, potencialmente perdemos reglas interesantes. Veamos cómo se comportan confianza y lift para el modelo donde no hay asociaciones. Utilizamos el modelo de independencia que explicamos arriba. Obsérvese que en este modelo todas las confianzas teóricas son iguales a la frecuencia del consecuente, y todos los valores teóricos de lift son \\(1\\): pars &lt;- list(support=0.002, confidence = 0.0, target=&quot;rules&quot;, ext = TRUE, minlen = 2) sims_reglas &lt;- map(1:10, function(i){ trans &lt;- simular_transacciones(n_items = 169, n_trans = 10000, prob = probs_items) ap_random &lt;- apriori(trans, parameter = pars, control = list(verbose = FALSE)) ap_random }) Y notamos que conforme el soporte de la regla es más bajo, hay más variabilidad en las estimaciones del confianza y lift. En este caso utilizamos plot(subset(sims_reglas[[4]], rhs %pin% &quot;whole milk&quot;), measure=c(&quot;support&quot;,&quot;confidence&quot;), shading = &quot;lift&quot;, engine = &quot;plotly&quot;) ## To reduce overplotting, jitter is added! Use jitter = 0 to prevent jitter. plot(subset(sims_reglas[[4]], rhs %pin% &quot;whole milk&quot;), measure=c(&quot;support&quot;,&quot;lift&quot;), shading = &quot;confidence&quot;, engine = &quot;plotly&quot;) ## To reduce overplotting, jitter is added! Use jitter = 0 to prevent jitter. El valor de confianza y de lift puede ser altamente variable para reglas con soporte bajo. Podemos tomar dos caminos: Cuando hagamos el soporte más bajo, incrementamos el valor de lift mínimo. Esto evita que obtengamos demasiadas reglas que no representan interacciones reales entre los artículos. Podemos usar otras medidas que tomen en cuenta la variabilidad de las estimaciones. Por ejemplo, hyper-lift y hyper-confidence están basados en modelos simples (como el que vimos arriba), que filtran aquellos valores de calidad que están en las colas de las distribuciones de los modelos simples. 2.9 Otras medidas de calidad de reglas Hay una gran cantidad de medidas de interés de reglas que se han propuesto desde que se usa el análisis de canasta. Aquí discutimos hyper-lift y hyper-confidence, que toman en cuenta el soporte de las reglas para proponer puntos de corte (Hahsler and Hornik 2008). Explicamos aquí el hyper-lift para una regla \\(i\\to j\\). Consideramos el modelo de independencia (lo pensamos como el modelo nulo), fijando las probabilidades de ocurrencia de los artículos según los datos (como hicimos en los ejemplos de arriba) y el número de transacciones. Bajo este modelo, el número de ocurrencias \\(X_{\\{i,j\\}}\\) de el itemset \\(\\{i,j\\}\\) es una variable aleatoria con distribución conocida (binomial). Esta distribución representa la variación que podemos observar en los conteos de \\(\\{i,j\\}\\) bajo distintas muestras de transacciones del mismo tamaño. La idea básica del hyperlift es comparar el conteo \\(n(\\{i,j\\})\\) con la cola superior de la distribución de \\(X_{i,j}\\) bajo el supuesto de independencia, poniendo \\[HL(I\\to j) = \\frac{n(\\{I,j\\})}{Q_\\delta (X_{I,j})},\\] donde \\(Q_\\delta\\) es tal que \\(P(X_{I,j} &lt; Q_\\delta (X_{I,j}))\\approx \\delta\\). Tomamos por ejemplo \\(\\delta=0.99\\). De esta forma, \\(HL&gt;1\\) sólo cuando el conteo observado \\(n(\\{i,j\\})\\) está en la cola superior del conteo bajo la hipótesis nula de independencia. Esto toma en cuenta la variabilidad de los conteos (que es grande en términos relativos cuando el soporte es bajo). Observaciones: El modelo de independencia que se usa en el paquete arules es una variación del que vimos aquí, ver los detalles en (Hahsler and Hornik 2008). Los valores de hyper-lift no son realmente comparables a los de lift, son dos medidas de calidad de asociación diferentes, pero similares en cuanto a lo que quieren capturar. Hyper-lift bajo hipótesis de independencia Veamos cómo se comporta el hyper-lift simulando datos con el modelo de independencia: trans &lt;- simular_transacciones(n_items = 169, n_trans = 10000, prob = probs_items) ap_random &lt;- apriori(trans, parameter = list(support=0.001, confidence = 0.10, target=&quot;rules&quot;, ext = TRUE, minlen = 2), control = list(verbose = FALSE)) agregar_hyperlift &lt;- function(reglas, trans){ quality(reglas) &lt;- cbind(quality(reglas), hyper_lift = interestMeasure(reglas, measure = &quot;hyperLift&quot;, transactions = trans)) reglas } ap_random &lt;- agregar_hyperlift(ap_random, trans) Vemos claramente que la gran mayoría de reglas obtenidas ahora tienen hyper-lift menor que uno plot(ap_random, measure=c(&quot;lift&quot;,&quot;hyper_lift&quot;), shading = &quot;support&quot;) ## To reduce overplotting, jitter is added! Use jitter = 0 to prevent jitter. Cortando en un valor relativamente bajo de hyper-lift, vemos que nos deshacemos correctamente de casi todas las reglas: length(ap_random) ## [1] 3591 length(subset(ap_random, lift &gt; 1)) ## [1] 2643 length(subset(ap_random, hyper_lift &gt; 1)) ## [1] 130 Hyper-lift para datos de canastas Ahora aplicamos a los datos reales pars &lt;- list(supp = 0.002, confidence = 0.10, target=&quot;rules&quot;, ext = TRUE, minlen = 2) reglas &lt;- apriori(lista_mb, parameter = pars, control = list(verbose=FALSE)) reglas &lt;- agregar_hyperlift(reglas, Groceries) length(reglas) ## [1] 8332 Vemos que podemos cortar niveles de hyper-lift donde obtenemos reglas de soporte relativamente alto. plot(reglas, measure=c(&quot;lift&quot;,&quot;hyper_lift&quot;), shading = &quot;support&quot;) ## To reduce overplotting, jitter is added! Use jitter = 0 to prevent jitter. Si cortamos en valores que dan un número similar de reglas, por ejemplo: filtradas_hl &lt;- subset(reglas, hyper_lift &gt; 2) filtradas_lift &lt;- subset(reglas, lift &gt; 3.7) length(filtradas_hl) ## [1] 439 length(filtradas_lift) ## [1] 480 Vemos que las reglas cortadas con hyper-lift tienen mejores valores de soporte: library(patchwork) soportes &lt;- qqplot( quality(filtradas_hl)$support, quality(filtradas_lift)$support, plot.it = FALSE) |&gt; as_tibble() g_soporte &lt;- ggplot(soportes, aes(x, y)) + geom_abline(colour = &quot;red&quot;) + geom_point(alpha = 0.5) + xlab(&quot;Soporte (filtro Hyperlift)&quot;) + ylab(&quot;Soporte (filtro Lift)&quot;) + coord_fixed(xlim = c(0, 0.03), ylim = c(0, 0.03)) + ggtitle(&quot;Soporte&quot;) soportes &lt;- qqplot( quality(filtradas_hl)$lift, quality(filtradas_lift)$lift, plot.it = FALSE) |&gt; as_tibble() g_lift &lt;- ggplot(soportes, aes(x, y)) + geom_abline(colour = &quot;red&quot;) + geom_point(alpha = 0.5) + xlab(&quot;Lift (filtro Hyperlift)&quot;) + ylab(&quot;Lift (filtro Lift)&quot;) + coord_fixed() + ggtitle(&quot;Lift&quot;) g_soporte + g_lift + plot_annotation( subtitle = &quot;Soporte y Lift con filtro de reglas por lift vs. hyperlift&quot;) La distribución de valores de lift no es tan diferente, de forma que esta medida de calidad no se degrada en el conjunto de reglas que encontramos: En resumen, al utilizar hyper-lift para filtrar reglas en lugar de lift obtenemos reglas de mejor calidad: Descartamos más reglas de soporte bajo que tienen lift alto por azar. Los valores de soporte de las reglas tienden a ser más altos. Los valores de lift son comparables 2.10 Selección de reglas Ahora discutiremos cómo seleccionar itemsets frecuentes y reglas. Filtrar con todos estos criterios (soporte, confianza, soporte del antecedente, lift) no es simple, y depende de los objetivos del análisis. Recordemos también que estos análisis están basados justamente en cortes “duros” de los datos, más o menos arbitrarios, y por lo tanto pueden los resultados son variables. Hay varias maneras de conducir el análisis. Dos tipos útiles son: Itemsets de alta frecuencia: en este enfoque buscamos reglas con soporte y confianza relativamente altos. Generalmente están asociados a productos muy frecuentes, y nos indica potencial de interacción entre los artículos. Este análisis es más una reexpresión de la información contenida en los itemsets frecuentes. En este caso, podemos filtrar con soporte alto, para evitar estimaciones ruidosas (por ejemplo, soporte mínimo de 300 canastas). Interacciones altas: en este enfoque donde buscamos entender nichos. Consideramos valores de soporte y confianza más bajos, pero con valores de lift/hyper-lift alto. Este análisis es más útil para entender, por ejemplo, propósitos de compras, convivencia de artículos, tipos de comprador, etc. Colección de reglas para hacer querys: la colección de reglas puede ser más grande, e incluir por ejemplo resultados de distintas corridas de market basket (incluyendo los dos enfoques de arriba). Las reglas se examinan seleccionando antecedentes o consecuentes, valores altos de soporte, etc, según la pregunta particular que se quiera explorar. Ejemplo: canastas grandes Para entender las canastas grandes, podemos variar valores de soporte y confianza para encontrar un número manejable de reglas. pars &lt;- list(support = 0.02, confidence = 0.20, minlen = 2, target=&quot;rules&quot;, ext = TRUE) reglas_1 &lt;- apriori(lista_mb, parameter = pars) Esta elección de parámetros resulta en 72. Podemos ordenar por hyper-lift: plot(reglas_1, colors=c(&quot;red&quot;, &quot;gray&quot;), engine = &quot;plotly&quot;) reglas_1 &lt;- agregar_hyperlift(reglas_1, lista_mb) DT::datatable(DATAFRAME(sort(reglas_1, by = &quot;hyper_lift&quot;)) |&gt; select(-count, -coverage) |&gt; mutate_if(is.numeric, ~ round(.x, 2))) Observaciones: conforme bajamos en esta tabla (ordenada por soporte), las estimaciones de confianza y lift son menos precisas. 2.11 Búsqueda de reglas especializadas Otra manera de usar este análisis es intenando buscar asociaciones más fuertes (lift o hyper-lift más alto), aún cuando sacrificamos soporte. Por su naturaleza, este tipo de análisis puede resultar en reglas más ruidosas (malas estimaciones de confianza y lift), pero es posible filtrar valores más altos de estas cantidades para encontrar reglas útiles. Comenzamos con un soporte y confianza más bajas pars &lt;- list(support = 0.001, confidence = 0.1, minlen = 2, target=&quot;rules&quot;, ext = TRUE) b_reglas &lt;- apriori(lista_mb, parameter = pars) b_reglas &lt;- agregar_hyperlift(b_reglas, lista_mb) Y ahora filtramos con valores más grandes de hyper-lift. Podemos filtrar adicionalmente con coverage para obtener reglas que aplican con más frecuencia: b_reglas ## set of 32783 rules b_reglas_lift &lt;- subset(b_reglas, hyper_lift &gt; 2.5 &amp; size(b_reglas) &lt; 4 &amp; coverage &gt; 0.01) b_reglas_lift &lt;- sort(b_reglas_lift, by = &quot;hyper_lift&quot;) DT::datatable(DATAFRAME(b_reglas_lift) |&gt; select(-count, -coverage) |&gt; mutate_if(is.numeric, ~ round(.x, 3))) 2.12 Visualización de asociaciones Tener una visión amplia del market basket analysis es difícil (típicamente, funciona mejor como un resultado al que se le hacen querys, o uno donde filtramos cuidadosamente algunas reglas que puedan ser útiles). Así que muchas veces ayuda visualizar los pares con asociación alta: Construimos todas las reglas con un antecedente y un consecuente. Filtramos las reglas con hyper-lift relativamente alto (por ejemplo &gt; \\(1.5\\), pero hay que experimentar). Representamos como una gráfica donde los nodos son artículos, y las aristas son relaciones de lift alto. Usamos algún algoritmo para representar gráficas basado en fuerza, usando como peso el lift. 2.12.1 Ejemplo En nuestro caso, podríamos tomar (ajustando parámetros para no obtener demasiadas reglas o demasiado pocas) b_reglas_lift &lt;- subset(b_reglas, hyper_lift &gt; 1.75 &amp; confidence &gt; 0.05) reglas_f &lt;- subset(b_reglas_lift, size(b_reglas_lift) == 2) library(tidygraph) library(ggraph) df_reglas &lt;- reglas_f |&gt; DATAFRAME() |&gt; rename(from = LHS, to = RHS) df_reglas$weight &lt;- log(df_reglas$hyper_lift) nrow(df_reglas) ## [1] 94 graph_1 &lt;- as_tbl_graph(df_reglas) |&gt; mutate(centrality = centrality_degree(mode = &quot;all&quot;)) ggraph(graph_1, layout = &quot;fr&quot;, start.temp=100) + geom_edge_link(aes(alpha=lift), colour = &quot;red&quot;, arrow = arrow(length = unit(4, &quot;mm&quot;))) + geom_node_point(aes(size = centrality, colour = centrality)) + geom_node_text(aes(label = name), size=4, colour = &quot;gray20&quot;, repel=TRUE) + theme_graph(base_family = &quot;sans&quot;) Para gráficas más grandes, es mejor usar software especializado para investigar las redes que obtenemos (como Gephi): b_reglas_lift &lt;- subset(b_reglas, hyper_lift &gt; 1.5 &amp; coverage &gt; 0.01) reglas_f &lt;- subset(b_reglas_lift, size(b_reglas_lift) == 2) length(reglas_f) ## [1] 251 reglas_f |&gt; DATAFRAME() |&gt; rename(source = LHS, target = RHS) |&gt; select(-count) |&gt; write_csv(file = &quot;./salidas/reglas.csv&quot;) Para el análisis de canastas grandes: reglas_f2 &lt;- subset(reglas_1, hyper_lift &gt; 1.3, confidence &gt; 0.4) df_reglas &lt;- reglas_f2 |&gt; DATAFRAME() |&gt; rename(from = LHS, to = RHS) df_reglas$weight &lt;- log(df_reglas$hyper_lift) graph_1 &lt;- as_tbl_graph(df_reglas) |&gt; mutate(centrality = centrality_degree(mode = &quot;all&quot;)) ggraph(graph_1, layout = &quot;fr&quot;, start.temp=100) + geom_edge_link(aes(alpha=hyper_lift), colour = &quot;red&quot;, arrow = arrow(length = unit(4, &quot;mm&quot;))) + geom_node_point(aes(size = centrality, colour = centrality)) + geom_node_text(aes(label = name), size=4, colour = &quot;gray20&quot;, repel=TRUE) + theme_graph(base_family = &quot;sans&quot;) 2.13 Otras aplicaciones Análisis de tablas de variables categóricas: podemos considerar una tabla con varias variables categóricas. Una canasta son los valores que toman las variables. Por ejemplo, podríamos encontrar reglas como {hogar = propio, ocupación=profesional} -&gt; ingreso = alto. Puedes ver más de este análisis en (Hastie, Tibshirani, and Friedman 2017), por ejemplo, sección 14.2. Conceptos relacionados: si los artículos son palabras y las canastas documentos (tweets, por ejemplo), este tipo de análisis (una vez que eliminamos las palabras más frecuentes, que no tienen significado como artículos, preposiciones, etc.), puede mostrar palabras que co-ocurren para formar conceptos relacionados. Plagiarismo: si los artículos son documentos y los canastas oraciones, el análisis de canastas puede encontrar documentos que contienen las mismas oraciones. Si varias canastas (oraciones) “contienen” los mismos artículos (documentos), entonces esas oraciones son indicadores de plagio 2.14 Ejercicios Considera los datos de datos/recetas. Lee los datos, asegúrate que puedes filtrar por tipo de cocina, y que puedes aplicarles la función apriori de arules (o cualquier otra herramienta que estés utilizando). Calcula la frecuencia de todos los artículos (ingredientes). El resto de este ejercicio lo haremos a principio de la siguiente clase. Acerca de los datos: Cada receta es una canasta, y los artículos son los ingredientes que usan. Puedes consultar el artículo original aquí. Haz algunos experimentos el ejemplo 2.12.1 que vimos en clase: incrementa/decrementa hyperlift, incrementa/decrementa soporte. ¿Qué pasa con las gráficas resultantes y el número de reglas? (Opcional) Muchas veces el análisis de canastas puede hacerse con una muestra de transacciones. Leer secciones 6.4.1 a 6.4.4 de (Leskovec, Rajaraman, and Ullman 2014). Referencias "],["similitud.html", "3 Similitud y vecinos cercanos 3.1 Similitud de conjuntos 3.2 Representación de documentos como conjuntos 3.3 Representación matricial 3.4 Minhash y reducción probabilística de dimensionalidad 3.5 Agrupando textos de similitud alta 3.6 Ejemplo: tweets", " 3 Similitud y vecinos cercanos En esta parte consideraremos la tarea de agrupar eficientemente elementos muy similares en conjuntos datos masivos. Algunos ejemplos de esta tarea son: Encontrar documentos similares en una colección de documentos. Esto puede servir para detectar plagio, deduplicar noticias o páginas web, hacer matching de datos de dos fuentes (por ejemplo, nombres completos de personas), etc. Ver por ejemplo Google News. Encontrar usuarios similares (Netflix), en el sentido de que tienen gustos similares, o películas similares, en el sentido de qe le gustan a las mismas personas. Encontrar imágenes similares en una colección grande, ver por ejemplo Pinterest. Uber: rutas similares que indican (fraude o abusos)[https://eng.uber.com/lsh/]. Deduplicar registros de usuarios de algún servicio (por ejemplo, beneficiarios de programas sociales). Estos problemas no son triviales por dos razones: Los elementos que queremos comparar muchas veces están naturalmente representados en espacios de dimensión alta, y es relativamente costoso comparar un par (documentos, imágenes, usuarios, rutas). Muchas veces es preferible construir una representación más compacta y hacer comparaciones con las versiones comprimidas. Si la colección de elementos es grande (\\(N\\)), entonces el número de pares posibles es del orden de \\(N^2\\), y es muy costoso hacer todas las posibles comparaciones para encontrar los elementos similares (por ejemplo, comparar \\(100\\) mil documentos, con unas \\(10\\) mil comparaciones por segundo, tardaría alrededor de \\(5\\) días). Si tenemos que calcular todas las similitudes, no hay mucho qué hacer. Pero muchas veces nos interesa encontrar pares de similitud alta, o completar tareas más específicas como contar duplicados, etc. En estos casos, veremos que es posible construir soluciones probabilísticas aproximadas para resolver estos problemas de forma escalable. Aunque veremos más adelante métricas de similitud comunes como la dada por la distancia euclideana o distancia coseno, por ejemplo, en esta primera parte nos concentramos en discutir similitud entre pares de textos. Los textos los podemos ver como colecciones de palabras, o de manera más general, como colecciones de cadenas. 3.1 Similitud de conjuntos Muchos de estos problemas de similitud se pueden pensar como problemas de similitud entre conjuntos. Por ejemplo, los documentos son conjuntos de palabras, conjuntos de pares de palabras, sucesiones de caracteres, una película se puede ver como el conjunto de personas a las que les gustó, o una ruta como un conjunto de tramos, etc. Hay muchas medidas que son útiles para cuantificar la similitud entre conjuntos. Una que es popular, y que explotaremos por sus propiedades, es la similitud de Jaccard: La similitud de Jaccard de los conjuntos \\(A\\) y \\(B\\) está dada por \\[sim(A,B) = \\frac{|A\\cap B|}{|A\\cup B|}\\] Esta medida cuantifica qué tan cerca está la unión de \\(A\\) y \\(B\\) de su intersección. Cuanto más parecidos sean \\(A\\cup B\\) y \\(A\\cap B\\), más similares son los conjuntos. En términos geométricos, es el área de la intersección entre el área de la unión. Ejercicio Calcula la similitud de Jaccard entre los conjuntos \\(A=\\{5,2,34,1,20,3,4\\}\\) y \\(B=\\{19,1,2,5\\}\\) library(tidyverse) options(digits = 3) sim_jaccard &lt;- \\(a, b) length(intersect(a, b)) / length(union(a, b)) sim_jaccard(c(0,1,2,5,8), c(1,2,5,8,9)) ## [1] 0.667 sim_jaccard(c(2,3,5,8,10), c(1,8,9,10)) ## [1] 0.286 sim_jaccard(c(3,2,5), c(8,9,1,10)) ## [1] 0 3.2 Representación de documentos como conjuntos Hay varias maneras de representar documentos como conjuntos. Las más simples son: Los documentos son colecciones de palabras, o conjuntos de sucesiones de palabras de tamaño \\(n\\). Los documentos son colecciones de caracteres, o conjuntos de sucesiones de caracteres (cadenas) de tamaño \\(k\\). La primera representación se llama representación de n-gramas, y la segunda representación de k-tejas, o \\(k\\)-shingles. Nótese que en ambos casos, representaciones de dos documentos con secciones parecidas acomodadas en distintos lugares tienden a ser similares. Consideremos una colección de textos cortos: textos &lt;- c(&quot;el perro persigue al gato pero no lo alcanza&quot;, &quot;el gato persigue al perro, pero no lo alcanza&quot;, &quot;este es el documento de ejemplo&quot;, &quot;este no es el documento de los ejemplos&quot;, &quot;documento más corto&quot;, &quot;otros animales pueden ser mascotas&quot;) Abajo mostramos la representacion en bolsa de palabras (1-gramas) y la representación en bigramas (2-gramas) de los primeros dos documentos: # Bolsa de palabras (1-gramas) tokenizers::tokenize_ngrams(textos[1:2], n = 1) |&gt; map(unique) ## [[1]] ## [1] &quot;el&quot; &quot;perro&quot; &quot;persigue&quot; &quot;al&quot; &quot;gato&quot; &quot;pero&quot; &quot;no&quot; ## [8] &quot;lo&quot; &quot;alcanza&quot; ## ## [[2]] ## [1] &quot;el&quot; &quot;gato&quot; &quot;persigue&quot; &quot;al&quot; &quot;perro&quot; &quot;pero&quot; &quot;no&quot; ## [8] &quot;lo&quot; &quot;alcanza&quot; # bigramas tokenizers::tokenize_ngrams(textos[1:2], n = 2) |&gt; map(unique) ## [[1]] ## [1] &quot;el perro&quot; &quot;perro persigue&quot; &quot;persigue al&quot; &quot;al gato&quot; ## [5] &quot;gato pero&quot; &quot;pero no&quot; &quot;no lo&quot; &quot;lo alcanza&quot; ## ## [[2]] ## [1] &quot;el gato&quot; &quot;gato persigue&quot; &quot;persigue al&quot; &quot;al perro&quot; ## [5] &quot;perro pero&quot; &quot;pero no&quot; &quot;no lo&quot; &quot;lo alcanza&quot; La representación en k-tejas es otra posibilidad: calcular_tejas &lt;- function(x, k = 2){ tokenizers::tokenize_character_shingles(x, n = k, lowercase = FALSE, simplify = TRUE, strip_non_alpha = FALSE) } # 2-tejas calcular_tejas(textos[1:2], k = 2) |&gt; map(unique) ## [[1]] ## [1] &quot;el&quot; &quot;l &quot; &quot; p&quot; &quot;pe&quot; &quot;er&quot; &quot;rr&quot; &quot;ro&quot; &quot;o &quot; &quot;rs&quot; &quot;si&quot; &quot;ig&quot; &quot;gu&quot; &quot;ue&quot; &quot;e &quot; &quot; a&quot; ## [16] &quot;al&quot; &quot; g&quot; &quot;ga&quot; &quot;at&quot; &quot;to&quot; &quot; n&quot; &quot;no&quot; &quot; l&quot; &quot;lo&quot; &quot;lc&quot; &quot;ca&quot; &quot;an&quot; &quot;nz&quot; &quot;za&quot; ## ## [[2]] ## [1] &quot;el&quot; &quot;l &quot; &quot; g&quot; &quot;ga&quot; &quot;at&quot; &quot;to&quot; &quot;o &quot; &quot; p&quot; &quot;pe&quot; &quot;er&quot; &quot;rs&quot; &quot;si&quot; &quot;ig&quot; &quot;gu&quot; &quot;ue&quot; ## [16] &quot;e &quot; &quot; a&quot; &quot;al&quot; &quot;rr&quot; &quot;ro&quot; &quot;o,&quot; &quot;, &quot; &quot; n&quot; &quot;no&quot; &quot; l&quot; &quot;lo&quot; &quot;lc&quot; &quot;ca&quot; &quot;an&quot; &quot;nz&quot; ## [31] &quot;za&quot; # 4-tejas:&quot; calcular_tejas(textos[1:2], k = 4) |&gt; map(unique) ## [[1]] ## [1] &quot;el p&quot; &quot;l pe&quot; &quot; per&quot; &quot;perr&quot; &quot;erro&quot; &quot;rro &quot; &quot;ro p&quot; &quot;o pe&quot; &quot;pers&quot; &quot;ersi&quot; ## [11] &quot;rsig&quot; &quot;sigu&quot; &quot;igue&quot; &quot;gue &quot; &quot;ue a&quot; &quot;e al&quot; &quot; al &quot; &quot;al g&quot; &quot;l ga&quot; &quot; gat&quot; ## [21] &quot;gato&quot; &quot;ato &quot; &quot;to p&quot; &quot;pero&quot; &quot;ero &quot; &quot;ro n&quot; &quot;o no&quot; &quot; no &quot; &quot;no l&quot; &quot;o lo&quot; ## [31] &quot; lo &quot; &quot;lo a&quot; &quot;o al&quot; &quot; alc&quot; &quot;alca&quot; &quot;lcan&quot; &quot;canz&quot; &quot;anza&quot; ## ## [[2]] ## [1] &quot;el g&quot; &quot;l ga&quot; &quot; gat&quot; &quot;gato&quot; &quot;ato &quot; &quot;to p&quot; &quot;o pe&quot; &quot; per&quot; &quot;pers&quot; &quot;ersi&quot; ## [11] &quot;rsig&quot; &quot;sigu&quot; &quot;igue&quot; &quot;gue &quot; &quot;ue a&quot; &quot;e al&quot; &quot; al &quot; &quot;al p&quot; &quot;l pe&quot; &quot;perr&quot; ## [21] &quot;erro&quot; &quot;rro,&quot; &quot;ro, &quot; &quot;o, p&quot; &quot;, pe&quot; &quot;pero&quot; &quot;ero &quot; &quot;ro n&quot; &quot;o no&quot; &quot; no &quot; ## [31] &quot;no l&quot; &quot;o lo&quot; &quot; lo &quot; &quot;lo a&quot; &quot;o al&quot; &quot; alc&quot; &quot;alca&quot; &quot;lcan&quot; &quot;canz&quot; &quot;anza&quot; Observaciones: Los tokens son las unidades básicas de análisis. Los tokens son palabras para los n-gramas (cuya definición no es del todo simple) y caracteres para las k-tejas. Podrían ser también oraciones, por ejemplo. Nótese que en ambos casos es posible hacer algo de preprocesamiento para obtener la representación. Transformaciones usuales son: Eliminar puntuación y/o espacios. Convertir los textos a minúsculas. Esto incluye decisiones acerca de qué hacer con palabras compuestas (por ejemplo, con un guión), palabras que denotan un concepto (Reino Unido, por ejemplo) y otros detalles. Si lo que nos interesa principalmente similitud textual (no significado, o polaridad, etc.) entre documentos, entonces podemos usar \\(k\\)-tejas, con un mínimo de preprocesamiento. Esta representación es simple y flexible en el sentido de que se puede adaptar para documentos muy cortos (mensajes o tweets, por ejemplo), pero también para documentos más grandes. Por estas razones, no concentramos por el momento en \\(k\\)-tejas Tejas (shingles) Sea \\(k&gt;0\\) un entero. Las \\(k\\)-tejas (\\(k\\)-shingles) de un documento d es el conjunto de todas las corridas (distintas) de \\(k\\) caracteres sucesivos. Escogemos \\(k\\) suficientemente grande, de forma que la probabilidad de que una teja particular ocurra en un texto dado sea relativamente baja. Ejemplo Documentos textualmente similares tienen tejas similares: # calcular tejas textos ## [1] &quot;el perro persigue al gato pero no lo alcanza&quot; ## [2] &quot;el gato persigue al perro, pero no lo alcanza&quot; ## [3] &quot;este es el documento de ejemplo&quot; ## [4] &quot;este no es el documento de los ejemplos&quot; ## [5] &quot;documento más corto&quot; ## [6] &quot;otros animales pueden ser mascotas&quot; tejas_doc &lt;- calcular_tejas(textos, k = 4) # calcular similitud de jaccard entre algunos pares sim_jaccard(tejas_doc[[1]], tejas_doc[[2]]) ## [1] 0.773 sim_jaccard(tejas_doc[[1]], tejas_doc[[3]]) ## [1] 0 sim_jaccard(tejas_doc[[4]], tejas_doc[[5]]) ## [1] 0.156 Podemos calcular todas las similitudes: tejas_tbl &lt;- crossing(id_1 = 1:length(textos), id_2 = 1:length(textos)) |&gt; filter(id_1 &lt; id_2) |&gt; mutate(tejas_1 = tejas_doc[id_1], tejas_2 = tejas_doc[id_2]) |&gt; mutate(sim = map2_dbl(tejas_1, tejas_2, ~sim_jaccard(.x, .y))) |&gt; select(id_1, id_2, sim) tejas_tbl ## # A tibble: 15 × 3 ## id_1 id_2 sim ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 0.773 ## 2 1 3 0 ## 3 1 4 0.0137 ## 4 1 5 0 ## 5 1 6 0 ## 6 2 3 0 ## 7 2 4 0.0133 ## 8 2 5 0 ## 9 2 6 0 ## 10 3 4 0.6 ## 11 3 5 0.189 ## 12 3 6 0 ## 13 4 5 0.156 ## 14 4 6 0 ## 15 5 6 0 pero nótese que, como señalamos arriba, esta operación será muy costosa incluso si la colección de textos es de tamaño moderado. Si los textos son cortos, entonces basta tomar valores como \\(k=4,5\\), pues hay un total de \\(27^4\\) tejas de tamaño \\(4\\), y el número de tejas de un documento corto (mensajes, tweets) es mucho más bajo que \\(27^4\\) (nota: ¿puedes explicar por qué este argumento no es exactamente correcto?) Para documentos grandes, como noticias o artículos, es mejor escoger un tamaño más grande, como \\(k=9,10\\), pues en documentos largos puede haber cientos de miles de caracteres. Si \\(k\\) fuera más chica entonces una gran parte de las tejas aparecerá en muchos de los documentos, y todos los documentos tendrían similitud alta. Evitamos escoger \\(k\\) demasiado grande, pues entonces los únicos documentos similares tendrían que tener subcadenas largas exactamente iguales. Por ejemplo: “Batman y Robin” y “Robin y Batman” son algo similares si usamos tejas de tamaño 3, pero son muy distintas si usamos tejas de tamaño 8: Ejemplo tejas_1 &lt;- calcular_tejas(&quot;Batman y Robin&quot;, k = 3) tejas_2 &lt;- calcular_tejas(&quot;Robin y Batman&quot;, k = 3) sim_jaccard(tejas_1, tejas_2) ## [1] 0.6 tejas_1 &lt;- calcular_tejas(&quot;Batman y Robin&quot;, k = 8) tejas_2 &lt;- calcular_tejas(&quot;Robin y Batman&quot;, k = 8) sim_jaccard(tejas_1, tejas_2) ## [1] 0 3.3 Representación matricial Podemos usar una matriz binaria para guardar todas las representaciones en k-tejas de nuestra colección de documentos. Puede usarse una representación rala (sparse) si es necesario: dtejas_tbl &lt;- tibble(id = paste0(&quot;doc_&quot;, 1:length(textos)), tejas = tejas_doc) |&gt; unnest(cols = tejas) |&gt; unique() |&gt; mutate(val = 1) |&gt; pivot_wider(names_from = id, values_from = val, values_fill = list(val = 0)) |&gt; arrange(tejas) # opcionalmente ordenamos tejas dtejas_tbl ## # A tibble: 123 × 7 ## tejas doc_1 doc_2 doc_3 doc_4 doc_5 doc_6 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 &quot; al &quot; 1 1 0 0 0 0 ## 2 &quot; alc&quot; 1 1 0 0 0 0 ## 3 &quot; ani&quot; 0 0 0 0 0 1 ## 4 &quot; cor&quot; 0 0 0 0 1 0 ## 5 &quot; de &quot; 0 0 1 1 0 0 ## 6 &quot; doc&quot; 0 0 1 1 0 0 ## 7 &quot; eje&quot; 0 0 1 1 0 0 ## 8 &quot; el &quot; 0 0 1 1 0 0 ## 9 &quot; es &quot; 0 0 1 1 0 0 ## 10 &quot; gat&quot; 1 1 0 0 0 0 ## # … with 113 more rows ¿Cómo calculamos la similitud de Jaccard usando estos datos? Calcular la unión e intersección se puede hacer haciendo OR y AND de las columnas, y entonces podemos calcular la similitud inter_12 &lt;- sum(dtejas_tbl$doc_1 &amp; dtejas_tbl$doc_2) union_12 &lt;- sum(dtejas_tbl$doc_1 | dtejas_tbl$doc_2) similitud &lt;- inter_12/union_12 similitud # comparar con el número que obtuvimos arriba. ## [1] 0.773 El cálculo para todos los documentos podríamos hacerlo (aunque veremos que normalmente no haremos esto si no necesitamos calcular todas las similitudes) con: mat_td &lt;- dtejas_tbl |&gt; select(-tejas) |&gt; as.matrix() |&gt; t() 1 - dist(mat_td, method = &quot;binary&quot;) ## doc_1 doc_2 doc_3 doc_4 doc_5 ## doc_2 0.7727 ## doc_3 0.0000 0.0000 ## doc_4 0.0137 0.0133 0.6000 ## doc_5 0.0000 0.0000 0.1892 0.1556 ## doc_6 0.0000 0.0000 0.0000 0.0000 0.0000 3.4 Minhash y reducción probabilística de dimensionalidad Para una colección grande de documentos la representación binaria de la colección de documentos puede tener un número muy grande de renglones. Puede ser posible crear un número más chico de nuevos features (ojo: aquí los renglones son las “variables,” y los casos son las columnas) con los que sea posible obtener una buena aproximación de la similitud. La idea básica es la siguiente: Supongamos que numeramos las tejas 1, 2, , N. Escogemos una función al azar (una función hash) que mapea cadenas cortas a un número grande de enteros, de manera existe muy baja probabilidad de colisiones, y no hay correlación entre las cadenas y el valor al que son mapeados. Si un documento tiene tejas \\(T\\), aplicamos la función hash a cada teja de \\(T\\), y calculamos el mínimo de estos valores hash. Repetimos este proceso para varias funciones hash fijas, por ejemplo \\(k= 5\\) Los valores mínimos obtenidos nos dan una representación en dimensión baja de cada documento. Ejemplo textos_tbl &lt;- tibble(doc_id = 1:length(textos), texto = textos) tejas_tbl &lt;- tibble(doc_id = 1:length(textos), tejas = tejas_doc) tejas_tbl ## # A tibble: 6 × 2 ## doc_id tejas ## &lt;int&gt; &lt;list&gt; ## 1 1 &lt;chr [41]&gt; ## 2 2 &lt;chr [42]&gt; ## 3 3 &lt;chr [28]&gt; ## 4 4 &lt;chr [36]&gt; ## 5 5 &lt;chr [16]&gt; ## 6 6 &lt;chr [31]&gt; Creamos una función hash: set.seed(813) generar_hash &lt;- function(){ r &lt;- as.integer(stats::runif(1, 1, 2147483647)) funcion_hash &lt;- function(tejas){ digest::digest2int(tejas, seed = r) } funcion_hash } h_1 &lt;- generar_hash() Y aplicamos la función a cada teja del documento 1, y tomamos el mínimo: hashes_1 &lt;- h_1(tejas_tbl$tejas[[1]]) hashes_1 ## [1] -1318809190 -1534091290 -1401861150 -1601894665 781339434 -519860631 ## [7] 2116727945 -1824301917 -1401861150 -1371561364 -1385084918 -821046029 ## [13] 1766711521 1952075680 569109680 -1412107908 1059544482 -1866546594 ## [19] 2090868926 -455965089 784118133 1421354549 -1397404756 -481987742 ## [25] -1824301917 -1401861150 1157451749 698137483 -623448608 544014704 ## [31] -587926856 1455454405 950121497 -165719415 2119479774 2115904977 ## [37] 1519310299 1652203243 -667865842 1219377605 -1500087628 minhash_1 &lt;- min(hashes_1) minhash_1 ## [1] -1866546594 Consideramos este minhash como un descriptor del documento. Generalmente usamos más de un descriptor. En el siguiente ejemplo usamos tres funciones hash creadas de manera independiente: hashes &lt;- map(1:4, ~ generar_hash()) docs_firmas &lt;- tejas_tbl |&gt; mutate(firma = map(tejas, \\(lista) map_int(hashes, \\(h) min(h(lista))))) |&gt; select(doc_id, firma) |&gt; unnest_wider(firma, names_sep = &quot;_&quot;) docs_firmas ## # A tibble: 6 × 5 ## doc_id firma_1 firma_2 firma_3 firma_4 ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 -2129712961 -2124594172 -2073157333 -1982715048 ## 2 2 -2129712961 -2124594172 -2073157333 -1982715048 ## 3 3 -2139075502 -2093452194 -1959662839 -2048484934 ## 4 4 -2139075502 -2093452194 -1959662839 -2048484934 ## 5 5 -2106131386 -2093452194 -2127642881 -1984764210 ## 6 6 -2115397946 -2087727654 -2074217109 -1986993146 Nótese ahora que en documentos muy similares, varios de los minhashes coinciden. Esto es porque la teja donde ocurrió el mínimo está en los dos documentos. Entonces cuando los las tejas de dos documentos son muy similares, es muy probable que sus minhashes coincidan. ¿Cuál es la probabilidad de que la firma coincida para un documento? Sea \\(h\\) una función hash escogida escogida al azar, y \\(a\\) y \\(b\\) dos documentos dados dadas. Entonces \\[P(minhash_h(a) = minhash_h(b)) = sim(a, b)\\] donde \\(sim\\) es la similitud de Jaccard basada en las tejas usadas. Sean \\(h_1, h_2, \\ldots h_n\\) funciones hash escogidas al azar de manera independiente. Si \\(n\\) es grande, entonces por la ley de los grandes números \\[sim(a,b) \\approx \\frac{|h_j : minhash_{h_j}{\\pi_j}(a) = minhash_{h_j}(b)|}{n},\\] es decir, la similitud de Jaccard es aproximadamente la proporción de elementos de las firmas que coinciden. Ahora damos un argumento para demostrar este resultado: Supongamos que el total de tejas de los dos documentos es \\(|A\\cup B|\\), y el número de tejas que tienen en común es \\(|A\\cap B|\\). Sea \\(h\\) la función hash que escogimos al azar. Para fijar ideas, puedes suponer que las tejas están numeradas \\(1,\\ldots, M\\), y la función hash es una permutación aleatoria de estos números. Entonces: El mínimo de \\(h\\) puede ocurrir en cualquier elemento de \\(|A\\cup B|\\) con la misma probabilidad. Los minhashes de \\(a\\) y \\(b\\) coinciden si y sólo si el mínimo de \\(h\\) ocurre en un elemento de \\(|A\\cap B|\\) Por 1 y 2, la probabilidad de que esto ocurra es \\[\\frac{|A\\cap B|}{|A\\cup B|},\\] que es la similitud de Jaccard. Nótese que esto requiere que la familia de donde escogemos nuestra función hash cumple, al menos aproximadamente, las propiedades 1 y 2. Para que 1 ocurra, la familia debe ser suficientemente grande y variada: por ejemplo, esto fallaría si todas las cadenas que comienzan con “a” se mapean a números chicos. Para que ocurra 2, no debe haber colisiones (cadenas distintas que se mapean al mismo valor). Observaciónes: Una familia que cumple de manera exacta estas dos propiedades es la familia de permutaciones que mencionamos arriba: numeramos las tejas, construimos una permutación al azar, y luego aplicamos esta función de permutaciones a los índices de las tejas. La razón por la que esta familia no es utiliza típicamente es porque es costosa si el número de tejas es grande: primero hay que escoger un ordenamiento al azar, y luego es necesario almacenarlo. Muchas veces, se utiliza una función hash con aritmética modular como sigue: sea \\(M\\) el número total de tejas, y sea \\(p\\) un número primo fijo grande (al menos \\(p &gt; M\\)). Numeramos las tejas. Ahora escogemos dos enteros \\(a\\) y \\(b\\) al azar, y hacemos \\[h(x) = (ax + b\\mod p) \\mod M\\] Estas funciones se pueden seleccionar y aplicar rápidamente, y sólo tenemos que almacenar los coeficientes \\(a\\) y \\(b\\). En el enfoque que vimos arriba, utilizamos directamente una función hash de cadenas que está diseñada para cumplir 1 y 2 de manera aproximada. Resumen. Con el método de minhash, representamos a los documentos con un número relativamente chico de atributos numéricos (reducción de dimensionalidad). Esta respresentación tiene la propiedad de que textos muy similares con probabilidad alta coinciden en uno o más de los descriptores. 3.5 Agrupando textos de similitud alta Nuestro siguiente paso es evitar hacer la comparación de todos los pares de descriptores. Para esto hacemos un clustering no exhaustivo basado en los descriptores que acabamos de construir. Recordemos que tenemos docs_firmas ## # A tibble: 6 × 5 ## doc_id firma_1 firma_2 firma_3 firma_4 ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 -2129712961 -2124594172 -2073157333 -1982715048 ## 2 2 -2129712961 -2124594172 -2073157333 -1982715048 ## 3 3 -2139075502 -2093452194 -1959662839 -2048484934 ## 4 4 -2139075502 -2093452194 -1959662839 -2048484934 ## 5 5 -2106131386 -2093452194 -2127642881 -1984764210 ## 6 6 -2115397946 -2087727654 -2074217109 -1986993146 Ahora agrupamos documentos que comparten alguna firma. A los grupos que coinciden en cada firma les lammamos cubetas: cubetas_tbl &lt;- docs_firmas |&gt; pivot_longer(contains(&quot;firma_&quot;), &quot;n_firma&quot;) |&gt; mutate(cubeta = paste(n_firma, value)) |&gt; group_by(cubeta) |&gt; summarise(documentos = list(doc_id)) |&gt; mutate(num_docs = map_int(documentos, length)) cubetas_tbl ## # A tibble: 15 × 3 ## cubeta documentos num_docs ## &lt;chr&gt; &lt;list&gt; &lt;int&gt; ## 1 firma_1 -2106131386 &lt;int [1]&gt; 1 ## 2 firma_1 -2115397946 &lt;int [1]&gt; 1 ## 3 firma_1 -2129712961 &lt;int [2]&gt; 2 ## 4 firma_1 -2139075502 &lt;int [2]&gt; 2 ## 5 firma_2 -2087727654 &lt;int [1]&gt; 1 ## 6 firma_2 -2093452194 &lt;int [3]&gt; 3 ## 7 firma_2 -2124594172 &lt;int [2]&gt; 2 ## 8 firma_3 -1959662839 &lt;int [2]&gt; 2 ## 9 firma_3 -2073157333 &lt;int [2]&gt; 2 ## 10 firma_3 -2074217109 &lt;int [1]&gt; 1 ## 11 firma_3 -2127642881 &lt;int [1]&gt; 1 ## 12 firma_4 -1982715048 &lt;int [2]&gt; 2 ## 13 firma_4 -1984764210 &lt;int [1]&gt; 1 ## 14 firma_4 -1986993146 &lt;int [1]&gt; 1 ## 15 firma_4 -2048484934 &lt;int [2]&gt; 2 Ahora filtramos las cubetas que tienen más de un elemento: cubetas_tbl &lt;- cubetas_tbl |&gt; filter(num_docs &gt; 1) cubetas_tbl ## # A tibble: 8 × 3 ## cubeta documentos num_docs ## &lt;chr&gt; &lt;list&gt; &lt;int&gt; ## 1 firma_1 -2129712961 &lt;int [2]&gt; 2 ## 2 firma_1 -2139075502 &lt;int [2]&gt; 2 ## 3 firma_2 -2093452194 &lt;int [3]&gt; 3 ## 4 firma_2 -2124594172 &lt;int [2]&gt; 2 ## 5 firma_3 -1959662839 &lt;int [2]&gt; 2 ## 6 firma_3 -2073157333 &lt;int [2]&gt; 2 ## 7 firma_4 -1982715048 &lt;int [2]&gt; 2 ## 8 firma_4 -2048484934 &lt;int [2]&gt; 2 Y de aquí extraemos pares candidatos que tienen alta probabilidad de ser muy similares: pares_tbl &lt;- cubetas_tbl |&gt; mutate(pares_cand = map(documentos, ~ combn(.x, 2, simplify = FALSE))) |&gt; select(cubeta, pares_cand) |&gt; unnest(pares_cand) |&gt; unnest_wider(pares_cand, names_sep = &quot;_&quot;) pares_tbl ## # A tibble: 10 × 3 ## cubeta pares_cand_1 pares_cand_2 ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 firma_1 -2129712961 1 2 ## 2 firma_1 -2139075502 3 4 ## 3 firma_2 -2093452194 3 4 ## 4 firma_2 -2093452194 3 5 ## 5 firma_2 -2093452194 4 5 ## 6 firma_2 -2124594172 1 2 ## 7 firma_3 -1959662839 3 4 ## 8 firma_3 -2073157333 1 2 ## 9 firma_4 -1982715048 1 2 ## 10 firma_4 -2048484934 3 4 pares_tbl &lt;- pares_tbl |&gt; select(-cubeta) |&gt; unique() pares_tbl ## # A tibble: 4 × 2 ## pares_cand_1 pares_cand_2 ## &lt;int&gt; &lt;int&gt; ## 1 1 2 ## 2 3 4 ## 3 3 5 ## 4 4 5 Nótese que con este proceso evitamos hacer todas las comparaciones, y el método tiene complejidad lineal en el tamaño de la colección de documentos. Una vez que tenemos los pares, podemos calcular la similitud exacta de solamente esos documentos: pares_tbl |&gt; left_join(tejas_tbl |&gt; rename(pares_cand_1 = doc_id, texto_1 = tejas)) |&gt; left_join(tejas_tbl |&gt; rename(pares_cand_2 = doc_id, texto_2 = tejas)) |&gt; mutate(score = map2_dbl(texto_1, texto_2, ~ sim_jaccard(.x, .y))) |&gt; select(-contains(&quot;texto&quot;)) ## Joining, by = &quot;pares_cand_1&quot; ## Joining, by = &quot;pares_cand_2&quot; ## # A tibble: 4 × 3 ## pares_cand_1 pares_cand_2 score ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 0.773 ## 2 3 4 0.6 ## 3 3 5 0.189 ## 4 4 5 0.156 Si queremos capturar solamente aquellos pares de similitud muy alta, podemos también combinar firmas para formar cubetas donde las dos firmas coinciden: cubetas_tbl &lt;- docs_firmas |&gt; mutate(cubeta = paste(firma_1, firma_2)) |&gt; group_by(cubeta) |&gt; summarise(documentos = list(doc_id)) |&gt; mutate(num_docs = map_int(documentos, length)) cubetas_tbl ## # A tibble: 4 × 3 ## cubeta documentos num_docs ## &lt;chr&gt; &lt;list&gt; &lt;int&gt; ## 1 -2106131386 -2093452194 &lt;int [1]&gt; 1 ## 2 -2115397946 -2087727654 &lt;int [1]&gt; 1 ## 3 -2129712961 -2124594172 &lt;int [2]&gt; 2 ## 4 -2139075502 -2093452194 &lt;int [2]&gt; 2 pares_tbl &lt;- cubetas_tbl |&gt; filter(num_docs &gt; 1) |&gt; mutate(pares_cand = map(documentos, ~ combn(.x, 2, simplify = FALSE))) |&gt; select(cubeta, pares_cand) |&gt; unnest(pares_cand) |&gt; unnest_wider(pares_cand, names_sep = &quot;_&quot;) |&gt; left_join(tejas_tbl |&gt; rename(pares_cand_1 = doc_id, texto_1 = tejas)) |&gt; left_join(tejas_tbl |&gt; rename(pares_cand_2 = doc_id, texto_2 = tejas)) |&gt; mutate(score = map2_dbl(texto_1, texto_2, ~ sim_jaccard(.x, .y))) |&gt; select(-contains(&quot;texto&quot;)) ## Joining, by = &quot;pares_cand_1&quot; ## Joining, by = &quot;pares_cand_2&quot; pares_tbl ## # A tibble: 2 × 4 ## cubeta pares_cand_1 pares_cand_2 score ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 -2129712961 -2124594172 1 2 0.773 ## 2 -2139075502 -2093452194 3 4 0.6 3.6 Ejemplo: tweets Ahora buscaremos tweets similares en una colección de un dataset de kaggle. "],["referencias.html", "Referencias", " Referencias "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
